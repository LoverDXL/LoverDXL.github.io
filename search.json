[{"title":"Hello World","url":"/2021/08/06/hello-world/","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"3.栈与队列","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"<h4 id=\"232-用栈实现队列\"><a href=\"#232-用栈实现队列\" class=\"headerlink\" title=\"232. 用栈实现队列\"></a><a href=\"https://leetcode-cn.com/problems/implement-queue-using-stacks/\">232. 用栈实现队列</a></h4><p>难度;简单</p>\n<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>\n<p>实现 <code>MyQueue</code> 类：</p>\n<ul>\n<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>\n<li><code>int pop()</code> 从队列的开头移除并返回元素</li>\n<li><code>int peek()</code> 返回队列开头的元素</li>\n<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>\n</ul>\n<p><strong>说明：</strong></p>\n<ul>\n<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>\n<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class=\"line\">[[], [1], [2], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, 1, 1, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MyQueue myQueue = new MyQueue();</span><br><span class=\"line\">myQueue.push(1); // queue is: [1]</span><br><span class=\"line\">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class=\"line\">myQueue.peek(); // return 1</span><br><span class=\"line\">myQueue.pop(); // return 1, queue is [2]</span><br><span class=\"line\">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= x &lt;= 9</code></li>\n<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>\n<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>方法一：双栈</strong><br><strong>思路</strong></p>\n<p>将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于pop 和peek 操作。</p>\n<p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyQueue</span> </span>&#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; in;</span><br><span class=\"line\">    Deque&lt;Integer&gt; out;</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyQueue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        in = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        out = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Push element x to the back of queue. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        in.push(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        in2out();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out.pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the front element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        in2out();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> out.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the queue is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">in2out</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(out.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!in.isEmpty())&#123;</span><br><span class=\"line\">                out.push(in.pop());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyQueue obj = new MyQueue();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.peek();</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：push 和 empty 为 O(1)，pop 和 peek 为均摊 O(1)。对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 O(1)。</p>\n</li>\n<li><p>空间复杂度：O(n)。其中 n 是操作总数。对于有 n 次 push 操作的情况，队列中会有 n 个元素，故空间复杂度为 O(n)。</p>\n</li>\n</ul>\n<h4 id=\"225-用队列实现栈\"><a href=\"#225-用队列实现栈\" class=\"headerlink\" title=\"225. 用队列实现栈\"></a><a href=\"https://leetcode-cn.com/problems/implement-stack-using-queues/\">225. 用队列实现栈</a></h4><p>难度：简单</p>\n<p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p>\n<p>实现 <code>MyStack</code> 类：</p>\n<ul>\n<li><code>void push(int x)</code> 将元素 x 压入栈顶。</li>\n<li><code>int pop()</code> 移除并返回栈顶元素。</li>\n<li><code>int top()</code> 返回栈顶元素。</li>\n<li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。</li>\n<li>你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;MyStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;top&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class=\"line\">[[], [1], [2], [], [], []]</span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null, null, null, 2, 2, false]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MyStack myStack = new MyStack();</span><br><span class=\"line\">myStack.push(1);</span><br><span class=\"line\">myStack.push(2);</span><br><span class=\"line\">myStack.top(); // 返回 2</span><br><span class=\"line\">myStack.pop(); // 返回 2</span><br><span class=\"line\">myStack.empty(); // 返回 False</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= x &lt;= 9</code></li>\n<li>最多调用<code>100</code> 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li>\n<li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空</li>\n</ul>\n<p><strong>进阶：</strong>你能否实现每种操作的均摊时间复杂度为 <code>O(1)</code> 的栈？换句话说，执行 <code>n</code> 个操作的总时间复杂度 <code>O(n)</code> ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p>\n<p><strong>解析：</strong>链接：<a href=\"https://leetcode-cn.com/problems/implement-stack-using-queues/solution/yong-dui-lie-shi-xian-zhan-by-leetcode-solution/\">用队列实现栈 - 用队列实现栈 - 力扣（LeetCode） (leetcode-cn.com)</a>  <strong>看方法二</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*Queue使用时要尽量避免Collection的add()和remove()方法，add()和remove()方法在失败的时候会抛出异常。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">要使用offer()来加入元素，使用poll()来获取并移出元素。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">它们的优点是通过返回值可以判断成功与否， 如果要使用前端而不移出该元素，使用element()或者peek()方法。</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">值得注意的是LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。</span></span><br><span class=\"line\"><span class=\"comment\">　　add         增加一个元索                          如果队列已满，则抛出一个IIIegaISlabEepeplian异常</span></span><br><span class=\"line\"><span class=\"comment\">　　remove   移除并返回队列头部的元素    如果队列为空，则抛出一个NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"comment\">　　element  返回队列头部的元素               如果队列为空，则抛出一个NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"comment\">　　offer        添加一个元素并返回true        如果队列已满，则返回false   *********主要使用*******</span></span><br><span class=\"line\"><span class=\"comment\">　　poll         移除并返问队列头部的元素    如果队列为空，则返回null   \t*******主要使用**********\t</span></span><br><span class=\"line\"><span class=\"comment\">　　peek       返回队列头部的元素               如果队列为空，则返回null   ******主要使用*******</span></span><br><span class=\"line\"><span class=\"comment\">　　put          添加一个元素                          如果队列满，则阻塞</span></span><br><span class=\"line\"><span class=\"comment\">　　take        移除并返回队列头部的元素    如果队列为空，则阻塞</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyStack</span> </span>&#123;</span><br><span class=\"line\">    Queue&lt;Integer&gt; queue;</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Push element x onto stack. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        queue.offer(x);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = queue.size();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cnt-- &gt;<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            queue.offer(queue.poll());</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span>  queue.poll();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Get the top element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.peek();       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the stack is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> queue.isEmpty();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MyStack obj = new MyStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(x);</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_2 = obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_4 = obj.empty();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"155-最小栈\"><a href=\"#155-最小栈\" class=\"headerlink\" title=\"155. 最小栈\"></a><a href=\"https://leetcode-cn.com/problems/min-stack/\">155. 最小栈</a></h4><p>难度：简单</p>\n<p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p>\n<ul>\n<li><code>push(x)</code> —— 将元素 x 推入栈中。</li>\n<li><code>pop()</code> —— 删除栈顶的元素。</li>\n<li><code>top()</code> —— 获取栈顶元素。</li>\n<li><code>getMin()</code> —— 检索栈中的最小元素。</li>\n</ul>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class=\"line\">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">[null,null,null,null,-3,null,0,-2]</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">MinStack minStack = new MinStack();</span><br><span class=\"line\">minStack.push(-2);</span><br><span class=\"line\">minStack.push(0);</span><br><span class=\"line\">minStack.push(-3);</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -3.</span><br><span class=\"line\">minStack.pop();</span><br><span class=\"line\">minStack.top();      --&gt; 返回 0.</span><br><span class=\"line\">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li>\n</ul>\n<p><strong>解析：</strong>来源链接：<a href=\"https://leetcode-cn.com/problems/min-stack/solution/zui-xiao-zhan-by-leetcode-solution/\">最小栈 - 最小栈 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MinStack</span> </span>&#123;</span><br><span class=\"line\">    Deque&lt;Integer&gt; stack;</span><br><span class=\"line\">    Deque&lt;Integer&gt; minStack;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> min;</span><br><span class=\"line\">    <span class=\"comment\">/** initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MinStack</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        minStack  = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">         min = Integer.MAX_VALUE;    </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"keyword\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        stack.push(val);</span><br><span class=\"line\">        min = Math.min(min,val);</span><br><span class=\"line\">        minStack.push(min);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        stack.pop();</span><br><span class=\"line\">        minStack.pop();</span><br><span class=\"line\">        min = minStack.isEmpty()?Integer.MAX_VALUE:minStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> stack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMin</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minStack.peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * MinStack obj = new MinStack();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.push(val);</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.pop();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_3 = obj.top();</span></span><br><span class=\"line\"><span class=\"comment\"> * int param_4 = obj.getMin();</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"20-有效的括号\"><a href=\"#20-有效的括号\" class=\"headerlink\" title=\"20. 有效的括号\"></a><a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">20. 有效的括号</a></h4><p>难度：简单</p>\n<p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p>\n<p>有效字符串需满足：</p>\n<ol>\n<li>左括号必须用相同类型的右括号闭合。</li>\n<li>左括号必须以正确的顺序闭合。</li>\n</ol>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;(]&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;([)]&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;&#123;[]&#125;&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 104</code></li>\n<li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li>\n</ul>\n<p><strong>解析：</strong>（自己解法）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValid</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Character&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c:s.toCharArray())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(c==<span class=\"string\">&#x27;(&#x27;</span> || c == <span class=\"string\">&#x27;[&#x27;</span> || c == <span class=\"string\">&#x27;&#123;&#x27;</span>)&#123;<span class=\"comment\">//如果是左括号则直接入栈</span></span><br><span class=\"line\">                stack.push(c);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123; <span class=\"comment\">//如果是右括号</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(stack.isEmpty())&#123; <span class=\"comment\">//如果此时栈为空，说明没有左括号 直接返回false</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> cStack = stack.pop();<span class=\"comment\">//否则弹栈出来比较</span></span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b1 = c ==<span class=\"string\">&#x27;)&#x27;</span> &amp;&amp; cStack != <span class=\"string\">&#x27;(&#x27;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b2 = c ==<span class=\"string\">&#x27;]&#x27;</span> &amp;&amp; cStack != <span class=\"string\">&#x27;[&#x27;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">boolean</span> b3 = c == <span class=\"string\">&#x27;&#125;&#x27;</span> &amp;&amp; cStack != <span class=\"string\">&#x27;&#123;&#x27;</span>;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(b1 || b2 ||b3)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stack.isEmpty();        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>其他解法</strong>：<a href=\"https://leetcode-cn.com/problems/valid-parentheses/solution/dai-ma-sui-xiang-lu-dai-ni-gao-ding-zhan-x3xw/\">「代码随想录」带你搞定栈与队列！20. 有效的括号【详解】 - 有效的括号 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<h4 id=\"739-每日温度\"><a href=\"#739-每日温度\" class=\"headerlink\" title=\"739. 每日温度\"></a><a href=\"https://leetcode-cn.com/problems/daily-temperatures/\">739. 每日温度</a></h4><p>难度：中等</p>\n<p>请根据每日 <code>气温</code> 列表 <code>temperatures</code> ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class=\"line\">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: temperatures = [30,40,50,60]</span><br><span class=\"line\">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: temperatures = [30,60,90]</span><br><span class=\"line\">输出: [1,1,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= temperatures.length &lt;= 105</code></li>\n<li><code>30 &lt;= temperatures[i] &lt;= 100</code></li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p>题解来源：<a href=\"https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/\">每日温度 - 每日温度 - 力扣（LeetCode） (leetcode-cn.com)</a>  方法二</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//用Deque实现栈 最好只使用  peek()查看栈顶 push()入栈 pop()出栈 三个方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] dailyTemperatures(<span class=\"keyword\">int</span>[] temperatures) &#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = temperatures.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] dist = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];<span class=\"comment\">//存储距离</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> curIdx =<span class=\"number\">0</span> ;curIdx &lt; n;curIdx++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack.isEmpty() &amp;&amp; temperatures[curIdx] &gt; temperatures[stack.peek()])&#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> preIdx = stack.pop();</span><br><span class=\"line\">                dist[preIdx] = curIdx- preIdx;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            stack.push(curIdx);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> dist;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"503-下一个更大元素-II\"><a href=\"#503-下一个更大元素-II\" class=\"headerlink\" title=\"503. 下一个更大元素 II\"></a><a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/\">503. 下一个更大元素 II</a></h4><p>难度：中等</p>\n<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,2,1]</span><br><span class=\"line\">输出: [2,-1,2]</span><br><span class=\"line\">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class=\"line\">数字 2 找不到下一个更大的数； </span><br><span class=\"line\">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/next-greater-element-ii/solution/cong-po-su-jie-fa-de-jiao-du-qu-li-jie-d-trht/\">为啥使用「单调栈」呀？从「朴素解法」的角度去理解「单调栈」 - 下一个更大元素 II - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] nextGreaterElements(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = nums.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] next = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];<span class=\"comment\">//造一个结果数组</span></span><br><span class=\"line\">        Arrays.fill(next,-<span class=\"number\">1</span>);<span class=\"comment\">//把数组中的值都赋值为-1</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n*<span class=\"number\">2</span>;i++)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历2n的数组长度</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = nums[i%n];</span><br><span class=\"line\">           <span class=\"comment\">//单调栈主要是把下标入栈</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; num )&#123;</span><br><span class=\"line\">                next[stack.pop()] = num;</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;n)&#123;</span><br><span class=\"line\">                stack.push(i);</span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"4.哈希表","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4-%E5%93%88%E5%B8%8C%E8%A1%A8/","content":"<p>哈希表使用 O(N) 空间复杂度存储数据，并且以 O(1) 时间复杂度求解问题。</p>\n<ul>\n<li>Java 中的 <strong>HashSet</strong> 用于存储一个集合，可以查找元素是否在集合中。如果元素有穷，并且范围不大，那么可以用一个布尔数组来存储一个元素是否存在。例如对于只有小写字符的元素，就可以用一个长度为 26 的布尔数组来存储一个字符集合，使得空间复杂度降低为 O(1)。</li>\n</ul>\n<p>Java 中的 <strong>HashMap</strong> 主要用于映射关系，从而把两个元素联系起来。HashMap 也可以用来对元素进行计数统计，此时键为元素，值为计数。和 HashSet 类似，如果元素有穷并且范围不大，可以用整型数组来进行统计。在对一个内容进行压缩或者其它转换时，利用 HashMap 可以把原始内容和转换后的内容联系起来。例如在一个简化 url 的系统中 [Leetcdoe : 535. Encode and Decode TinyURL (Medium)</p>\n<p><a href=\"https://leetcode.com/problems/encode-and-decode-tinyurl/description/\">Leetcode</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�) / <a href=\"https://leetcode-cn.com/problems/encode-and-decode-tinyurl/description/\">力扣</a>，利用 HashMap 就可以存储精简后的 url 到原始 url 的映射，使得不仅可以显示简化的 url，也可以根据简化的 url 得到原始 url 从而定位到正确的资源�)</p>\n<h4 id=\"1-两数之和\"><a href=\"#1-两数之和\" class=\"headerlink\" title=\"1. 两数之和\"></a><a href=\"https://leetcode-cn.com/problems/two-sum/\">1. 两数之和</a></h4><p>难度：简单</p>\n<p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p>\n<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>\n<p>你可以按任意顺序返回答案。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [2,7,11,15], target = 9</span><br><span class=\"line\">输出：[0,1]</span><br><span class=\"line\">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,2,4], target = 6</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,3], target = 6</span><br><span class=\"line\">输出：[0,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n<li><strong>只会存在一个有效答案</strong></li>\n</ul>\n<p><strong>进阶：</strong>你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/two-sum/solution/jie-suan-fa-1-liang-shu-zhi-he-by-guanpengchn/\">画解算法：1. 两数之和 - 两数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();<span class=\"comment\">//这里的hashMap key是存的数组中的值，value是存的对应在数组中的下班标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(target - nums[i]))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;map.get(target-nums[i]),i&#125;;<span class=\"comment\">//get方法是获取VALUE值</span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                map.put(nums[i],i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"217-存在重复元素\"><a href=\"#217-存在重复元素\" class=\"headerlink\" title=\"217. 存在重复元素\"></a><a href=\"https://leetcode-cn.com/problems/contains-duplicate/\">217. 存在重复元素</a></h4><p>难度：简单</p>\n<p>给定一个整数数组，判断是否存在重复元素。</p>\n<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,2,3,1]</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,2,3,4]</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析：</strong></p>\n<p>来源链接：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; set = <span class=\"keyword\">new</span> HashSet&lt;&gt;();<span class=\"comment\">//因为Set集合是不可重复的，无序的</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums)&#123;</span><br><span class=\"line\">            set.add(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> set.size() &lt; nums.length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>自己用HashMap 写的  ==真蠢==</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(nums[i])) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> map.put(nums[i],i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"594-最长和谐子序列\"><a href=\"#594-最长和谐子序列\" class=\"headerlink\" title=\"594. 最长和谐子序列\"></a><a href=\"https://leetcode-cn.com/problems/longest-harmonious-subsequence/\">594. 最长和谐子序列</a></h4><p>难度：简单</p>\n<p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 <strong>正好是 <code>1</code></strong> 。</p>\n<p>现在，给你一个整数数组 <code>nums</code> ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p>\n<p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,2,2,5,2,3,7]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：最长的和谐子序列是 [3,2,2,2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,3,4]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,1,1]</span><br><span class=\"line\">输出：0</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接:<a href=\"https://leetcode-cn.com/problems/longest-harmonious-subsequence/solution/zui-chang-he-xie-zi-xu-lie-by-leetcode/\">最长和谐子序列 - 最长和谐子序列 - 力扣（LeetCode） (leetcode-cn.com)</a>  方法二</p>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findLHS</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;Integer,Integer&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();<span class=\"comment\">//这里key存的是数组中的值，value存的是个数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num: nums)&#123;</span><br><span class=\"line\">            map.put(num,map.getOrDefault(num,<span class=\"number\">0</span>) +<span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。</span></span><br><span class=\"line\">            <span class=\"comment\">//getOrDefault() 方法的语法为：</span></span><br><span class=\"line\">            <span class=\"comment\">// hashmap.get(Object key, V defaultValue)</span></span><br><span class=\"line\">            <span class=\"comment\">// 注：hashmap 是 HashMap 类的一个对象。</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> longest =<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : map.keySet())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(map.containsKey(num+<span class=\"number\">1</span>))&#123;</span><br><span class=\"line\">                longest = Math.max(longest,map.get(num)+ map.get(num+<span class=\"number\">1</span>));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longest;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"128-最长连续序列\"><a href=\"#128-最长连续序列\" class=\"headerlink\" title=\"128. 最长连续序列\"></a><a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/\">128. 最长连续序列</a></h4><p>难度：中等</p>\n<p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>\n<p>请你设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [100,4,200,1,3,2]</span><br><span class=\"line\">输出：4</span><br><span class=\"line\">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class=\"line\">输出：9</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= nums.length &lt;= 105</code></li>\n<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/\">最长连续序列 - 最长连续序列 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestConsecutive</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;Integer&gt; num_set = <span class=\"keyword\">new</span> HashSet&lt;Integer&gt;();<span class=\"comment\">//利用set 去重</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : nums) &#123;</span><br><span class=\"line\">            num_set.add(num);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> longestStreak = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> num : num_set) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!num_set.contains(num - <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentNum = num;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> currentStreak = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (num_set.contains(currentNum + <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">                    currentNum += <span class=\"number\">1</span>;</span><br><span class=\"line\">                    currentStreak += <span class=\"number\">1</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                longestStreak = Math.max(longestStreak, currentStreak);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestStreak;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"5.字符串","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5-%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"<h4 id=\"242-有效的字母异位词\"><a href=\"#242-有效的字母异位词\" class=\"headerlink\" title=\"242. 有效的字母异位词\"></a><a href=\"https://leetcode-cn.com/problems/valid-anagram/\">242. 有效的字母异位词</a></h4><p>难度：简单</p>\n<p>给定两个字符串 <code>*s*</code> 和 <code>*t*</code> ，编写一个函数来判断 <code>*t*</code> 是否是 <code>*s*</code> 的字母异位词。</p>\n<p><strong>注意：</strong>若 <code>*s*</code> 和 <code>*t*</code> 中每个字符出现的次数都相同，则称 <code>*s*</code> 和 <code>*t*</code> 互为字母异位词。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length, t.length &lt;= 5 * 104</code></li>\n<li><code>s</code> 和 <code>t</code> 仅包含小写字母</li>\n</ul>\n<p><strong>进阶:</strong> 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/valid-anagram/solution/hua-jie-suan-fa-242-you-xiao-de-zi-mu-yi-wei-ci-by/\">画解算法：242. 有效的字母异位词 - 有效的字母异位词 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isAnagram</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] cnts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">26</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : s.toCharArray())&#123;</span><br><span class=\"line\">            cnts[c-<span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : t.toCharArray())&#123;</span><br><span class=\"line\">            cnts[c-<span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt :cnts)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt != <span class=\"number\">0</span> ) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h4 id=\"409-最长回文串\"><a href=\"#409-最长回文串\" class=\"headerlink\" title=\"409. 最长回文串\"></a><a href=\"https://leetcode-cn.com/problems/longest-palindrome/\">409. 最长回文串</a></h4><p>难度：简单</p>\n<p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p>\n<p>在构造过程中，请注意区分大小写。比如 <code>&quot;Aa&quot;</code> 不能当做一个回文字符串。</p>\n<p><strong>注意:</strong><br>假设字符串的长度不会超过 1010。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\">&quot;abccccdd&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br><span class=\"line\"></span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析：</strong></p>\n<p><strong>来源链接：</strong><a href=\"https://leetcode-cn.com/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/\">最长回文串 - 最长回文串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>代码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] cnts = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">256</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c: s.toCharArray())&#123;</span><br><span class=\"line\">            cnts[c]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> cnt : cnts)&#123;</span><br><span class=\"line\">            res += (cnt/<span class=\"number\">2</span>)*<span class=\"number\">2</span>;<span class=\"comment\">//这里除以2的原因就是 如果是该字符是奇数个，那么则保留偶数个</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(res &lt; s.length())&#123;<span class=\"comment\">//这个条件下s中一定有单个未使用的字符存在，可以把这个字符放在回文的最中间</span></span><br><span class=\"line\">            res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"205-同构字符串\"><a href=\"#205-同构字符串\" class=\"headerlink\" title=\"205. 同构字符串\"></a><a href=\"https://leetcode-cn.com/problems/isomorphic-strings/\">205. 同构字符串</a></h4><p>难度：简单</p>\n<p>给定两个字符串 <em><strong>s</strong></em> 和 ***t***，判断它们是否是同构的。</p>\n<p>如果 <em><strong>s</strong></em> 中的字符可以按某种映射关系替换得到 *<strong>t*</strong> ，那么这两个字符串是同构的。</p>\n<p>每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>可以假设 <em><strong>s</strong></em> 和 <strong>t</strong> 长度相同。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/isomorphic-strings/solution/tong-gou-zi-fu-chuan-by-leetcode-solutio-s6fd/\">同构字符串 - 同构字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>类似方法二来源：<a href=\"https://leetcode-cn.com/problems/isomorphic-strings/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-42/\">详细通俗的思路分析，多解法 - 同构字符串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isIsomorphic</span><span class=\"params\">(String s, String t)</span> </span>&#123;</span><br><span class=\"line\">        Map&lt;Character,Character&gt; s2t = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        Map&lt;Character,Character&gt; t2s = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = s.length();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> x = s.charAt(i),y=t.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s2t.containsKey(x) &amp;&amp; s2t.get(x) !=y || t2s.containsKey(y) &amp;&amp;t2s.get(y) != x)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            s2t.put(x,y);</span><br><span class=\"line\">            t2s.put(y,x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"647-回文子串\"><a href=\"#647-回文子串\" class=\"headerlink\" title=\"647. 回文子串\"></a><a href=\"https://leetcode-cn.com/problems/palindromic-substrings/\">647. 回文子串</a></h4><p>难度：中等</p>\n<p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p>\n<p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：&quot;abc&quot;</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：&quot;aaa&quot;</span><br><span class=\"line\">输出：6</span><br><span class=\"line\">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>输入的字符串长度不会超过 1000 </li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/palindromic-substrings/solution/liang-dao-hui-wen-zi-chuan-de-jie-fa-xiang-jie-zho/\">两道回文子串的解法（详解中心扩展法） - 回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>从字符串的某一位开始，尝试着去扩展字符串</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countSubstrings</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;s.length();i++)&#123;</span><br><span class=\"line\">            extendString(s,i,i);<span class=\"comment\">//奇数长度</span></span><br><span class=\"line\">            extendString(s,i,i+<span class=\"number\">1</span>);<span class=\"comment\">//偶数长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cnt;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">extendString</span><span class=\"params\">(String s, <span class=\"keyword\">int</span> start, <span class=\"keyword\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(start &gt;=<span class=\"number\">0</span> &amp;&amp; end &lt; s.length() &amp;&amp; s.charAt(start) == s.charAt(end))&#123;</span><br><span class=\"line\">            start--;</span><br><span class=\"line\">            end++;</span><br><span class=\"line\">            cnt++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"9-回文数\"><a href=\"#9-回文数\" class=\"headerlink\" title=\"9. 回文数\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-number/\">9. 回文数</a></h4><p>难度：简单</p>\n<p>给你一个整数 <code>x</code> ，如果 <code>x</code> 是一个回文整数，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，<code>121</code> 是回文，而 <code>123</code> 不是。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = 121</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = -121</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = 10</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = -101</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>-231 &lt;= x &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>进阶：</strong>你能不将整数转为字符串来解决这个问题吗？</p>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/palindrome-number/solution/hui-wen-shu-by-leetcode-solution/\">回文数 - 回文数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x==<span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(x &lt; <span class=\"number\">0</span> || x % <span class=\"number\">10</span> ==<span class=\"number\">0</span>)  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( x &gt; right)&#123;</span><br><span class=\"line\">            right =  right *<span class=\"number\">10</span> + x%<span class=\"number\">10</span>;<span class=\"comment\">//这里像相当于 把 1221 中后半部分 21 变成 12</span></span><br><span class=\"line\">            x/=<span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  x == right /<span class=\"number\">10</span>  || x == right;<span class=\"comment\">//当x是奇位数（如：121）用 x == right /10 判断，否则偶数就用 x == right 判断       </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"696-计数二进制子串\"><a href=\"#696-计数二进制子串\" class=\"headerlink\" title=\"696. 计数二进制子串\"></a><a href=\"https://leetcode-cn.com/problems/count-binary-substrings/\">696. 计数二进制子串</a></h4><p>难度：简单</p>\n<p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。</p>\n<p>重复出现的子串要计算它们出现的次数。</p>\n<p><strong>示例 1 :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;00110011&quot;</span><br><span class=\"line\">输出: 6</span><br><span class=\"line\">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</span><br><span class=\"line\"></span><br><span class=\"line\">请注意，一些重复出现的子串要计算它们出现的次数。</span><br><span class=\"line\"></span><br><span class=\"line\">另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2 :</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: &quot;10101&quot;</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>s.length</code> 在1到50,000之间。</li>\n<li><code>s</code> 只包含“0”或“1”字符。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/count-binary-substrings/solution/ji-shu-er-jin-zhi-zi-chuan-by-leetcode-solution/\">计数二进制子串 - 计数二进制子串 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">countBinarySubstrings</span><span class=\"params\">(String s)</span> </span>&#123;        <span class=\"keyword\">int</span> preLength = <span class=\"number\">0</span>,curLength = <span class=\"number\">1</span>, count = <span class=\"number\">0</span>;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i &lt; s.length();i++)&#123;            <span class=\"keyword\">if</span>(s.charAt(i) == s.charAt(i-<span class=\"number\">1</span>))&#123;                curLength++;            &#125;<span class=\"keyword\">else</span>&#123;                preLength = curLength;                curLength = <span class=\"number\">1</span>;<span class=\"comment\">//遇到不同的数，重置为1            &#125;            if(preLength &gt;= curLength)&#123;                 // 比如现在子串为110，(preLength##2&gt;1##curLength)那么连0和连1数量相同子串为1个，即10;                // 如果为1100，(preLength##2=2##curLength)那么连0和连1数量相同子串为2个，即10，1100;                // 如果为11000，那么连0和连1数量相同子串也为2个，即10，1100，所以此时count不用加1                count++;            &#125;        &#125;        return count;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"双指针","url":"/2021/08/06/%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","content":"<h4 id=\"167-两数之和-II-输入有序数组\"><a href=\"#167-两数之和-II-输入有序数组\" class=\"headerlink\" title=\"167. 两数之和 II - 输入有序数组\"></a><a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\">167. 两数之和 II - 输入有序数组</a></h4><p>难度:简单</p>\n<p>给定一个已按照 <strong>升序排列</strong> 的整数数组 <code>numbers</code> ，请你从数组中找出两个数满足相加之和等于目标数 <code>target</code> 。</p>\n<p>函数应该以长度为 <code>2</code> 的整数数组的形式返回这两个数的下标值<em>。</em><code>numbers</code> 的下标 <strong>从 1 开始计数</strong> ，所以答案数组应当满足 <code>1 &lt;= answer[0] &lt; answer[1] &lt;= numbers.length</code> 。</p>\n<p>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numbers = [2,7,11,15], target = 9</span><br><span class=\"line\">输出：[1,2]</span><br><span class=\"line\">解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numbers = [2,3,4], target = 6</span><br><span class=\"line\">输出：[1,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numbers = [-1,0], target = -1</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= numbers.length &lt;= 3 * 104</code></li>\n<li><code>-1000 &lt;= numbers[i] &lt;= 1000</code></li>\n<li><code>numbers</code> 按 <strong>递增顺序</strong> 排列</li>\n<li><code>-1000 &lt;= target &lt;= 1000</code></li>\n<li>仅存在一个有效答案</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/solution/liang-shu-zhi-he-ii-shu-ru-you-xu-shu-zu-by-leet-2/\">两数之和 II - 输入有序数组 - 两数之和 II - 输入有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] twoSum(<span class=\"keyword\">int</span>[] numbers, <span class=\"keyword\">int</span> target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numbers == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i  = <span class=\"number\">0</span>, j = numbers.length-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = numbers[i] + numbers[j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == target)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i+<span class=\"number\">1</span>,j+<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">              </span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; target)&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"633-平方数之和\"><a href=\"#633-平方数之和\" class=\"headerlink\" title=\"633. 平方数之和\"></a><a href=\"https://leetcode-cn.com/problems/sum-of-square-numbers/\">633. 平方数之和</a></h4><p>难度:中等</p>\n<p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a2 + b2 = c</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：c = 5</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：c = 3</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：c = 4</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：c = 2</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：c = 1</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= c &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/sum-of-square-numbers/solution/shuang-zhi-zhen-de-ben-zhi-er-wei-ju-zhe-ebn3/\">为什么双指针不会错过正确答案？双指针的本质。 - 平方数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">judgeSquareSum</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i  = <span class=\"number\">0</span>, j = (<span class=\"keyword\">int</span>)Math.sqrt(c);<span class=\"comment\">//从double转为int 需要强转</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i &lt;= j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum  = i * i + j * j;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum == c)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &gt; c)&#123;</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">             </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"345-反转字符串中的元音字母\"><a href=\"#345-反转字符串中的元音字母\" class=\"headerlink\" title=\"345. 反转字符串中的元音字母\"></a><a href=\"https://leetcode-cn.com/problems/reverse-vowels-of-a-string/\">345. 反转字符串中的元音字母</a></h4><p>难度:简单</p>\n<p>编写一个函数，以字符串作为输入，反转该字符串中的元音字母。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：&quot;hello&quot;</span><br><span class=\"line\">输出：&quot;holle&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：&quot;leetcode&quot;</span><br><span class=\"line\">输出：&quot;leotcede&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>元音字母不包含字母 “y” 。</li>\n</ul>\n<p><strong>解析;</strong></p>\n<p><a href=\"https://camo.githubusercontent.com/17ebd4ccaad189dd486211b3e18e20287541acf35cb203dd510aef61bfcdc301/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61376362383432332d383935642d343937352d386566382d3636326130303239633737322e706e67\"><img src=\"https://camo.githubusercontent.com/17ebd4ccaad189dd486211b3e18e20287541acf35cb203dd510aef61bfcdc301/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61376362383432332d383935642d343937352d386566382d3636326130303239633737322e706e67\" alt=\"img\"></a></p>\n<p>使用双指针，一个指针从头向尾遍历，一个指针从尾到头遍历，当两个指针都遍历到元音字符时，交换这两个元音字符。</p>\n<p>为了快速判断一个字符是不是元音字符，我们将全部元音字符添加到集合 HashSet 中，从而以 O(1) 的时间复杂度进行该操作。</p>\n<ul>\n<li>时间复杂度为 O(N)：只需要遍历所有元素一次</li>\n<li>空间复杂度 O(1)：只需要使用两个额外变量</li>\n</ul>\n<p><a href=\"https://camo.githubusercontent.com/8bed07b0617ab2350feddf81b28b3a3c3e6a6d69adcbbde555576514a3ac50c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65663235666637632d306636332d343230642d386233302d6561666265656133356431312e676966\"><img src=\"https://camo.githubusercontent.com/8bed07b0617ab2350feddf81b28b3a3c3e6a6d69adcbbde555576514a3ac50c6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65663235666637632d306636332d343230642d386233302d6561666265656133356431312e676966\" alt=\"img\"></a></p>\n<figure class=\"highlight markdown\"><table><tr><td class=\"code\"><pre><span class=\"line\"> Arrays.asList()该方法是将数组转化成List集合的方法。</span><br><span class=\"line\"></span><br><span class=\"line\"> List<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">String</span>&gt;</span></span> list = Arrays.asList(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">（1）该方法适用于对象型数据的数组（String、Integer...）</span><br><span class=\"line\"></span><br><span class=\"line\">（2）该方法不建议使用于基本数据类型的数组（byte,short,int,long,float,double,boolean）</span><br><span class=\"line\"></span><br><span class=\"line\">（3）该方法将数组与List列表链接起来：当更新其一个时，另一个自动更新</span><br><span class=\"line\"></span><br><span class=\"line\">（4）不支持add()、remove()、clear()等方法</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">static</span> HashSet&lt;Character&gt; vowels = <span class=\"keyword\">new</span> HashSet&lt;&gt;( <span class=\"comment\">//这里HashSet也可以换成List</span></span><br><span class=\"line\">        Arrays.asList(<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;i&#x27;</span>, <span class=\"string\">&#x27;o&#x27;</span>, <span class=\"string\">&#x27;u&#x27;</span>, <span class=\"string\">&#x27;A&#x27;</span>, <span class=\"string\">&#x27;E&#x27;</span>, <span class=\"string\">&#x27;I&#x27;</span>, <span class=\"string\">&#x27;O&#x27;</span>, <span class=\"string\">&#x27;U&#x27;</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">reverseVowels</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = s.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[s.length()];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (i &lt;= j) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ci = s.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">char</span> cj = s.charAt(j);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!vowels.contains(ci)) &#123;</span><br><span class=\"line\">            result[i++] = ci;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!vowels.contains(cj)) &#123;</span><br><span class=\"line\">            result[j--] = cj;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result[i++] = cj;</span><br><span class=\"line\">            result[j--] = ci;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> String(result);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"680-验证回文字符串-Ⅱ\"><a href=\"#680-验证回文字符串-Ⅱ\" class=\"headerlink\" title=\"680. 验证回文字符串 Ⅱ\"></a><a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/\">680. 验证回文字符串 Ⅱ</a></h4><p>难度:简单</p>\n<p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;aba&quot;</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abca&quot;</span><br><span class=\"line\">输出: true</span><br><span class=\"line\">解释: 你可以删除c字符。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: s = &quot;abc&quot;</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 105</code></li>\n<li><code>s</code> 由小写英文字母组成</li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/valid-palindrome-ii/solution/yan-zheng-hui-wen-zi-fu-chuan-ii-by-leetcode-solut/\">验证回文字符串 Ⅱ - 验证回文字符串 Ⅱ - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">validPalindrome</span><span class=\"params\">(String s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span> ,j = s.length()-<span class=\"number\">1</span>;i&lt;j;i++,j--)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i) != s.charAt(j))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> isPalindrome(s,i+<span class=\"number\">1</span>,j) || isPalindrome(s,i,j-<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(String s , <span class=\"keyword\">int</span> i ,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i++) != s.charAt(j--))&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"88-合并两个有序数组\"><a href=\"#88-合并两个有序数组\" class=\"headerlink\" title=\"88. 合并两个有序数组\"></a><a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">88. 合并两个有序数组</a></h4><p>难度:简单</p>\n<p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p>\n<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class=\"line\">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>nums1.length == m + n</code></li>\n<li><code>nums2.length == n</code></li>\n<li><code>0 &lt;= m, n &lt;= 200</code></li>\n<li><code>1 &lt;= m + n &lt;= 200</code></li>\n<li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/merge-sorted-array/solution/hua-jie-suan-fa-88-he-bing-liang-ge-you-xu-shu-zu-/\">画解算法：88. 合并两个有序数组 - 合并两个有序数组 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums1, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span>[] nums2, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index1 = m-<span class=\"number\">1</span>,index2 = n -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mergeIndex = m+n-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index2 &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(index1 &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                nums1[mergeIndex--] = nums2[index2--];</span><br><span class=\"line\">            <span class=\"comment\">//以下index2&lt;0 这个判断可写可不写    </span></span><br><span class=\"line\">            <span class=\"comment\">//&#125;else if(index2 &lt; 0)&#123;</span></span><br><span class=\"line\">                <span class=\"comment\">// nums1[mergeIndex--] = nums1[index1--];    </span></span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums1[index1] &gt; nums2[index2])&#123;</span><br><span class=\"line\">                nums1[mergeIndex--] = nums1[index1--];</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                nums1[mergeIndex--] = nums2[index2--];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"141-环形链表\"><a href=\"#141-环形链表\" class=\"headerlink\" title=\"141. 环形链表\"></a><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141. 环形链表</a></h4><p>难度:简单</p>\n<p>给定一个链表，判断链表中是否有环。</p>\n<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>\n<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>\n<p><strong>进阶：</strong></p>\n<p>你能用 *O(1)*（即，常量）内存解决此问题吗？</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [3,2,0,-4], pos = 1</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2], pos = 0</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1], pos = -1</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：链表中没有环。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 104]</code></li>\n<li><code>-105 &lt;= Node.val &lt;= 105</code></li>\n<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int x) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         val = x;</span></span><br><span class=\"line\"><span class=\"comment\"> *         next = null;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasCycle</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        ListNode slow = head,fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>( fast != <span class=\"keyword\">null</span> &amp;&amp; fast.next!= <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(slow == fast) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>; <span class=\"comment\">// 先移动再判断，避免两个都在head还没移动的情况</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>解题思路</strong></p>\n<p>此题可以定义一个fast和slow两个引用，先开始让他们都指向头节点。然后让fast一次性走2步，slow一次性走一步，如果他们可以相遇，则证明链表有环。不让fast一次性走更多步的原因是，虽然可能相遇更快点，但也有可能相遇更慢，或者永远也相遇不了，这样的话不太稳定。因此我们选择让fast这个快引用一次走2步！</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123;</span><br><span class=\"line\"> *         val = x;</span><br><span class=\"line\"> *         next = null;</span><br><span class=\"line\"> *     &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">public class Solution &#123;</span><br><span class=\"line\">    public boolean hasCycle(ListNode head) &#123;</span><br><span class=\"line\">        ListNode fast=head;</span><br><span class=\"line\">        ListNode slow=head;//定义快慢引用</span><br><span class=\"line\">        while(fast!=null&amp;&amp;fast.next!=null)&#123;</span><br><span class=\"line\">            //fast!=null要写在前面，这样由于短路与的特性，当前面为真时后面的条件就不执行了，就不会空指针异常了</span><br><span class=\"line\">            fast=fast.next.next;</span><br><span class=\"line\">            slow=slow.next;</span><br><span class=\"line\">            if(fast==slow)&#123;</span><br><span class=\"line\">                return true;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"524-通过删除字母匹配到字典里最长单词\"><a href=\"#524-通过删除字母匹配到字典里最长单词\" class=\"headerlink\" title=\"524. 通过删除字母匹配到字典里最长单词\"></a><a href=\"https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/\">524. 通过删除字母匹配到字典里最长单词</a></h4><p>难度：中等</p>\n<p>给你一个字符串 <code>s</code> 和一个字符串数组 <code>dictionary</code> 作为字典，找出并返回字典中最长的字符串，该字符串可以通过删除 <code>s</code> 中的某些字符得到。</p>\n<p>如果答案不止一个，返回长度最长且字典序最小的字符串。如果答案不存在，则返回空字符串。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;ale&quot;,&quot;apple&quot;,&quot;monkey&quot;,&quot;plea&quot;]</span><br><span class=\"line\">输出：&quot;apple&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：s = &quot;abpcplea&quot;, dictionary = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br><span class=\"line\">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= s.length &lt;= 1000</code></li>\n<li><code>1 &lt;= dictionary.length &lt;= 1000</code></li>\n<li><code>1 &lt;= dictionary[i].length &lt;= 1000</code></li>\n<li><code>s</code> 和 <code>dictionary[i]</code> 仅由小写英文字母组成</li>\n</ul>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">findLongestWord</span><span class=\"params\">(String s, List&lt;String&gt; dictionary)</span> </span>&#123;</span><br><span class=\"line\">        String longestWord = <span class=\"string\">&quot;&quot;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String target : dictionary)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> l1 = longestWord.length(),l2 = target.length();</span><br><span class=\"line\">            <span class=\"comment\">//   java中的compareto方法，返回参与比较的前后两个字符串的asc码的差值</span></span><br><span class=\"line\">            <span class=\"comment\">/// 获取长度最长且字典顺序最小的字符串</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(l1 &gt; l2 || (l1==l2) &amp;&amp; longestWord.compareTo(target) &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isSubstr(s,target))&#123;</span><br><span class=\"line\">                longestWord = target;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> longestWord;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">// 判断 target 是否为 s 的子序列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubstr</span><span class=\"params\">(String s,String target)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(s.charAt(i) == target.charAt(j))&#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> j == target.length();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","categories":["leetcode","算法"],"tags":["算法"]},{"title":"7.图","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7-%E5%9B%BE/","content":"<h1 id=\"二分图\"><a href=\"#二分图\" class=\"headerlink\" title=\"二分图\"></a>二分图</h1><p>如果可以用两种颜色对图中的节点进行着色，并且保证相邻的节点颜色不同，那么这个图就是二分图。</p>\n<h4 id=\"785-判断二分图\"><a href=\"#785-判断二分图\" class=\"headerlink\" title=\"785. 判断二分图\"></a><a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/\">785. 判断二分图</a></h4><p>难度：中等</p>\n<p>存在一个 <strong>无向图</strong> ，图中有 <code>n</code> 个节点。其中每个节点都有一个介于 <code>0</code> 到 <code>n - 1</code> 之间的唯一编号。给你一个二维数组 <code>graph</code> ，其中 <code>graph[u]</code> 是一个节点数组，由节点 <code>u</code> 的邻接节点组成。形式上，对于 <code>graph[u]</code> 中的每个 <code>v</code> ，都存在一条位于节点 <code>u</code> 和节点 <code>v</code> 之间的无向边。该无向图同时具有以下属性：</p>\n<ul>\n<li>不存在自环（<code>graph[u]</code> 不包含 <code>u</code>）。</li>\n<li>不存在平行边（<code>graph[u]</code> 不包含重复值）。</li>\n<li>如果 <code>v</code> 在 <code>graph[u]</code> 内，那么 <code>u</code> 也应该在 <code>graph[v]</code> 内（该图是无向图）</li>\n<li>这个图可能不是连通图，也就是说两个节点 <code>u</code> 和 <code>v</code> 之间可能不存在一条连通彼此的路径。</li>\n</ul>\n<p><strong>二分图</strong> 定义：如果能将一个图的节点集合分割成两个独立的子集 <code>A</code> 和 <code>B</code> ，并使图中的每一条边的两个节点一个来自 <code>A</code> 集合，一个来自 <code>B</code> 集合，就将这个图称为 <strong>二分图</strong> 。</p>\n<p>如果图是二分图，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：graph = [[1,3],[0,2],[1,3],[0,2]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125; 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>graph.length == n</code></li>\n<li><code>1 &lt;= n &lt;= 100</code></li>\n<li><code>0 &lt;= graph[u].length &lt; n</code></li>\n<li><code>0 &lt;= graph[u][i] &lt;= n - 1</code></li>\n<li><code>graph[u]</code> 不会包含 <code>u</code></li>\n<li><code>graph[u]</code> 的所有值 <strong>互不相同</strong></li>\n<li>如果 <code>graph[u]</code> 包含 <code>v</code>，那么 <code>graph[v]</code> 也会包含 <code>u</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/\">BFS + DFS + 并查集，三种方法判断二分图 - 判断二分图 - 力扣（LeetCode） (leetcode-cn.com)</a>方法二</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBipartite</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] graph)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 定义 visited 数组，初始值为 0 表示未被访问，赋值为 1 或者 -1 表示两种不同的颜色。 </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] visited = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[graph.length];</span><br><span class=\"line\">        <span class=\"comment\">// 因为图中可能含有多个连通域，所以我们需要判断是否存在顶点未被访问，若存在则从它开始再进行一轮 dfs 染色。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; graph.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited[i] == <span class=\"number\">0</span> &amp;&amp; !dfs(graph, i, <span class=\"number\">1</span>, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] graph, <span class=\"keyword\">int</span> v, <span class=\"keyword\">int</span> color, <span class=\"keyword\">int</span>[] visited)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如果要对某顶点染色时，发现它已经被染色了，则判断它的颜色是否与本次要染的颜色相同，如果矛盾，说明此无向图无法被正确染色，返回 false。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (visited[v] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> visited[v] == color;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 对当前顶点进行染色，并将当前顶点的所有邻接点染成相反的颜色。</span></span><br><span class=\"line\">        visited[v] = color;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> w: graph[v]) &#123; <span class=\"comment\">//对相邻节点遍历，看是否能染成不同颜色，因为题目是给的类似[0,2]两节点构成一个元素的数组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!dfs(graph, w, -color, visited)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"拓扑排序\"><a href=\"#拓扑排序\" class=\"headerlink\" title=\"拓扑排序\"></a>拓扑排序</h1><p><strong>一.定义</strong></p>\n<p>  对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若&lt;u，v&gt; ∈E(G)，则u在线性序列中出现在v之前。</p>\n<p>  通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。</p>\n<p>  注意:</p>\n<p>  1)只有有向无环图才存在拓扑序列;</p>\n<p>  2)对于一个DAG,可能存在多个拓扑序列;</p>\n<h4 id=\"207-课程表\"><a href=\"#207-课程表\" class=\"headerlink\" title=\"207. 课程表\"></a><a href=\"https://leetcode-cn.com/problems/course-schedule/\">207. 课程表</a></h4><p>难度：中等</p>\n<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>\n<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>\n<ul>\n<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>\n</ul>\n<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= numCourses &lt;= 105</code></li>\n<li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li>\n<li><code>prerequisites[i].length == 2</code></li>\n<li><code>0 &lt;= ai, bi &lt; numCourses</code></li>\n<li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li>\n</ul>\n<p><strong>解析:</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/course-schedule/solution/course-schedule-tuo-bu-pai-xu-bfsdfsliang-chong-fa/\">课程表（拓扑排序：入度表BFS法 / DFS法，清晰图解） - 课程表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">canFinish</span><span class=\"params\">(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//初始化邻接矩阵</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++)</span><br><span class=\"line\">            adjacency.add(<span class=\"keyword\">new</span> ArrayList&lt;&gt;()); <span class=\"comment\">//添加numCourses个数组</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] flags = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses]; <span class=\"comment\">//每个课程对应的flag</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] cp : prerequisites)  <span class=\"comment\">//把每个匹配单独取出来</span></span><br><span class=\"line\">            adjacency.get(cp[<span class=\"number\">1</span>]).add(cp[<span class=\"number\">0</span>]); <span class=\"comment\">//这里就是创建一个邻接表，即在cp[1]这个位置添加cp[0]这个数</span></span><br><span class=\"line\">        <span class=\"comment\">// cp[1]是前导课程，然后访问adj的第cp[1]个位置，然后添加cp[0]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numCourses; i++)</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(adjacency, flags, i)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//依次遍历adj每个位置</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">dfs</span><span class=\"params\">(List&lt;List&lt;Integer&gt;&gt; adjacency, <span class=\"keyword\">int</span>[] flags, <span class=\"keyword\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flags[i] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(flags[i] == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        flags[i] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(Integer j : adjacency.get(i))</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!dfs(adjacency, flags, j)) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>; <span class=\"comment\">//遍历i的每个邻居节点</span></span><br><span class=\"line\">        flags[i] = -<span class=\"number\">1</span>; <span class=\"comment\">//完成该轮遍历时，flag置为-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>分析：</strong></p>\n<p>主要分析了方法二：深度优先遍历</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">记住这三个标志位对应的状态</span></span><br><span class=\"line\"><span class=\"string\">i</span> <span class=\"string\">==</span> <span class=\"number\">0</span> <span class=\"string\">：</span> <span class=\"string\">干净的，未被</span> <span class=\"string\">DFS</span> <span class=\"string\">访问</span></span><br><span class=\"line\"><span class=\"string\">i</span> <span class=\"string\">==</span> <span class=\"number\">-1</span><span class=\"string\">：其他节点启动的</span> <span class=\"string\">DFS</span> <span class=\"string\">访问过了，路径没问题，不需要再访问了</span></span><br><span class=\"line\"><span class=\"string\">i</span> <span class=\"string\">==</span> <span class=\"number\">1</span>  <span class=\"string\">：本节点启动的</span> <span class=\"string\">DFS</span> <span class=\"string\">访问过了，一旦遇到了也说明有环了</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">有0、1、2、3、4、5</span>  <span class=\"string\">共6门课程。</span> [[<span class=\"number\">5</span>,<span class=\"number\">3</span>],[<span class=\"number\">5</span>,<span class=\"number\">4</span>],[<span class=\"number\">3</span>,<span class=\"number\">0</span>],[<span class=\"number\">3</span>,<span class=\"number\">1</span>],[<span class=\"number\">4</span>,<span class=\"number\">1</span>],[<span class=\"number\">4</span>,<span class=\"number\">2</span>]]<span class=\"string\">。学5之前要先学3，学5之前要先学4......</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">0</span>          <span class=\"string\">邻接表</span></span><br><span class=\"line\">   <span class=\"string\">\\</span>       <span class=\"string\">下标</span>  <span class=\"number\">0</span>     <span class=\"number\">1</span>     <span class=\"number\">2</span>     <span class=\"number\">3</span>    <span class=\"number\">4</span>    <span class=\"number\">5</span>   <span class=\"string\">同时也表示要先学的课程</span></span><br><span class=\"line\">   <span class=\"string\">/</span>   <span class=\"number\">3</span>        [<span class=\"number\">3</span>]  [<span class=\"number\">3</span>,<span class=\"number\">4</span>]  [<span class=\"number\">4</span>]   [<span class=\"number\">5</span>]  [<span class=\"number\">5</span>]  [ ]  <span class=\"string\">学完上面的课程才能学的课程，例如学完0才能学3，学完1才能学3和4</span></span><br><span class=\"line\"><span class=\"number\">1</span>        <span class=\"string\">\\</span></span><br><span class=\"line\">   <span class=\"string\">\\</span>     <span class=\"string\">/</span>  <span class=\"number\">5</span>     <span class=\"string\">这个邻接表的创建是通过</span>        <span class=\"string\">for(int[]</span> <span class=\"attr\">cp :</span> <span class=\"string\">prerequisites)</span></span><br><span class=\"line\">      <span class=\"number\">4</span>                                           <span class=\"string\">adjacency.get(cp[1]).add(cp[0]);</span>         <span class=\"string\">实现的</span></span><br><span class=\"line\">   <span class=\"string\">/</span>  </span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">然后就是遍历+标记判断有无环：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span><span class=\"string\">、从课程0启动DFS，先判断下，哦，节点0还没被访问，将flag[0]置1，表明被当前节点启动的dfs访问过了，在访问0时</span></span><br><span class=\"line\"><span class=\"string\">就通过以下代码一连串把3、5都访问了,返回true之前标志位置-1，这样从其他节点进来看到标志位-1时就无需再访问了，</span></span><br><span class=\"line\"><span class=\"string\">直接返回true.</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(flags[i] == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;  <span class=\"comment\">//先判断再修改标志位</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(flags[i] == -<span class=\"number\">1</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;  <span class=\"comment\">//别的dfs路径访问过了，我不需要访问了</span></span><br><span class=\"line\">flags[i] = <span class=\"number\">1</span>;   <span class=\"comment\">//只有这个标志位是干净的，别人还没有动过，我才能标记为1，说明本次dfs我遍历过它</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(Integer j : adjacency.get(i))</span><br><span class=\"line\">   <span class=\"keyword\">if</span>(!dfs(adjacency, flags, j))</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">flags[i] = -<span class=\"number\">1</span>;    <span class=\"comment\">//只有一次DFS完整结束了，才能执行到这一步，标记为-1，说明这条路没问题，再遇到不需要遍历了</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2.</span>从课程<span class=\"number\">1</span>启动DFS一样的道理，<span class=\"number\">3</span>、<span class=\"number\">5</span>上一步已经访问过了标志位为-<span class=\"number\">1</span>，这一步就不访问了，只要访问<span class=\"number\">4</span>，并把标志位置为-<span class=\"number\">1.</span>,</span><br><span class=\"line\"><span class=\"number\">3</span>、剩下的同理。这里是举了个无环的情况，那有环是什么样子呢？</span><br><span class=\"line\">下标  <span class=\"number\">0</span>     <span class=\"number\">1</span>     <span class=\"number\">2</span>     <span class=\"number\">3</span>    <span class=\"number\">4</span>    <span class=\"number\">5</span>   先学的课程</span><br><span class=\"line\">     [<span class=\"number\">3</span>]  [<span class=\"number\">3</span>,<span class=\"number\">4</span>]  [<span class=\"number\">4</span>]   [<span class=\"number\">5</span>]  [<span class=\"number\">5</span>]  [<span class=\"number\">3</span> ]  这里多加了一个，先学<span class=\"number\">5</span>才能学<span class=\"number\">3</span>，这回肯定就有问题了</span><br><span class=\"line\"></span><br><span class=\"line\">在第一步从课程<span class=\"number\">0</span>启动DFS，一连串访问<span class=\"number\">3</span>，<span class=\"number\">5</span>，从<span class=\"number\">5</span>又遍历到<span class=\"number\">3</span>时，由于我们本节点启动的dfs已经访问过<span class=\"number\">3</span>了，标志位为<span class=\"number\">1</span>，</span><br><span class=\"line\">所以碰到标志位为<span class=\"number\">1</span>，说明有环了，直接返回<span class=\"keyword\">false</span>;一旦某次df返回了<span class=\"keyword\">false</span>,整个遍历就结束了，返回最终结果<span class=\"keyword\">false</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n<h4 id=\"210-课程表-II\"><a href=\"#210-课程表-II\" class=\"headerlink\" title=\"210. 课程表 II\"></a><a href=\"https://leetcode-cn.com/problems/course-schedule-ii/\">210. 课程表 II</a></h4><p>难度：中等</p>\n<p>现在你总共有 <em>n</em> 门课需要选，记为 <code>0</code> 到 <code>n-1</code>。</p>\n<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: <code>[0,1]</code></p>\n<p>给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。</p>\n<p>可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 2, [[1,0]] </span><br><span class=\"line\">输出: [0,1]</span><br><span class=\"line\">解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class=\"line\">输出: [0,1,2,3] or [0,2,1,3]</span><br><span class=\"line\">解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class=\"line\">     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明:</strong></p>\n<ol>\n<li>输入的先决条件是由<strong>边缘列表</strong>表示的图形，而不是邻接矩阵。详情请参见<a href=\"http://blog.csdn.net/woaidapaopao/article/details/51732947\">图的表示法</a>。</li>\n<li>你可以假定输入的先决条件中没有重复的边。</li>\n</ol>\n<p><strong>提示:</strong></p>\n<ol>\n<li>这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。</li>\n<li><a href=\"https://www.coursera.org/specializations/algorithms\">通过 DFS 进行拓扑排序</a> - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。</li>\n<li>拓扑排序也可以通过 <a href=\"https://baike.baidu.com/item/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/5224802?fr=aladdin&fromid=2148012&fromtitle=%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2\">BFS</a> 完成。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<p><strong>未创建邻接表</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/course-schedule-ii/solution/java-jian-dan-hao-li-jie-de-tuo-bu-pai-xu-by-kelly/\">Java 简单好理解的拓扑排序 - 课程表 II - 力扣（LeetCode） (leetcode-cn.com)</a>方法一</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findOrder(<span class=\"keyword\">int</span> numCourses, <span class=\"keyword\">int</span>[][] prerequisites) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(numCourses == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] inDegrees = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] p : prerequisites)&#123;</span><br><span class=\"line\">            inDegrees[p[<span class=\"number\">0</span>]]++;<span class=\"comment\">//建立入度表，p是存储的数组，例如[1,0]即p[0]位置是入度为1</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//入度为0的节点队列</span></span><br><span class=\"line\">        Deque&lt;Integer&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">0</span>;i&lt;inDegrees.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(inDegrees[i] == <span class=\"number\">0</span>) queue.offer(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;<span class=\"comment\">//记录可以学完的课程数量</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[numCourses];<span class=\"comment\">//可以学完的课程</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curr = queue.poll();</span><br><span class=\"line\">            res[count++] = curr;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span>[] p : prerequisites)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(p[<span class=\"number\">1</span>] == curr)&#123;<span class=\"comment\">//判断是否有下一个节点的先修课程节点是否等于该节点，这里也就是判断邻接节点，如果有，则它的入度减一</span></span><br><span class=\"line\">                    inDegrees[p[<span class=\"number\">0</span>]]--;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(inDegrees[p[<span class=\"number\">0</span>]] == <span class=\"number\">0</span>) queue.offer(p[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count == numCourses) <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>创建邻接表：</strong></p>\n<p><a href=\"https://leetcode-cn.com/problems/course-schedule-ii/solution/tuo-bu-pai-xu-shen-du-you-xian-bian-li-python-dai-/\">拓扑排序（广度优先遍历） + 深度优先遍历（Java、Python） - 课程表 II - 力扣（LeetCode） (leetcode-cn.com)</a>方法一</p>\n<h1 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h1><h4 id=\"684-冗余连接\"><a href=\"#684-冗余连接\" class=\"headerlink\" title=\"684. 冗余连接\"></a><a href=\"https://leetcode-cn.com/problems/redundant-connection/\">684. 冗余连接</a></h4><p>难度：中等</p>\n<p>树可以看成是一个连通且 <strong>无环</strong> 的 <strong>无向</strong> 图。</p>\n<p>给定往一棵 <code>n</code> 个节点 (节点值 <code>1～n</code>) 的树中添加一条边后的图。添加的边的两个顶点包含在 <code>1</code> 到 <code>n</code> 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 <code>n</code> 的二维数组 <code>edges</code> ，<code>edges[i] = [ai, bi]</code> 表示图中在 <code>ai</code> 和 <code>bi</code> 之间存在一条边。</p>\n<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 <code>n</code> 个节点的树。如果有多个答案，则返回数组 <code>edges</code> 中最后出现的边。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://pic.leetcode-cn.com/1626676174-hOEVUL-image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: edges = [[1,2], [1,3], [2,3]]输出: [2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://pic.leetcode-cn.com/1626676179-kGxcmu-image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: edges = [[1,2], [2,3], [3,4], [1,4], [1,5]]输出: [1,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>n == edges.length</code></li>\n<li><code>3 &lt;= n &lt;= 1000</code></li>\n<li><code>edges[i].length == 2</code></li>\n<li><code>1 &lt;= ai &lt; bi &lt;= edges.length</code></li>\n<li><code>ai != bi</code></li>\n<li><code>edges</code> 中无重复元素</li>\n<li>给定的图是连通的 </li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/redundant-connection/solution/java-bing-cha-ji-by-luma730/\">java 并查集 - 冗余连接 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findRedundantConnection(<span class=\"keyword\">int</span>[][] edges) &#123;        <span class=\"keyword\">int</span> nodeCount = edges.length;        <span class=\"keyword\">int</span>[] parent  = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[nodeCount + <span class=\"number\">1</span>];        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span> ; i&lt;=nodeCount;i++)&#123;            parent[i] = i;<span class=\"comment\">//初始化        &#125;         for(int i = 0;i&lt;nodeCount;i++)&#123;            int[] edge = edges[i];//二维数组里面的数组元素，即连通线            int node1 = edge[0], node2 = edge[1];            if(find(parent,node1) != find(parent,node2))&#123;                union(parent,node1,node2);            &#125;else&#123;                return edge;            &#125;        &#125;        return new int[0];           &#125;    public void union(int[] parent,int index1,int index2)&#123;        parent[find(parent,index1)] = find(parent,index2);        //也可以写成parent[find(parent,index2)] = find(parent,index1);    &#125;    public int find(int[] parent,int index)&#123;        if(parent[index] != index)&#123;            parent[index] = find(parent,parent[index]);//找到parent[index]的父节点，直到找到根节点        &#125;        return parent[index];    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"6.数组与矩阵","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6-%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/","content":"<h4 id=\"283-移动零\"><a href=\"#283-移动零\" class=\"headerlink\" title=\"283. 移动零\"></a><a href=\"https://leetcode-cn.com/problems/move-zeroes/\">283. 移动零</a></h4><p>难度：简单</p>\n<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [0,1,0,3,12]</span><br><span class=\"line\">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明</strong>:</p>\n<ol>\n<li>必须在原数组上操作，不能拷贝额外的数组。</li>\n<li>尽量减少操作次数。</li>\n</ol>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/\">动画演示 283.移动零 - 移动零 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span> ;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num != <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">                nums[idx++] = num;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(idx &lt; nums.length)&#123;</span><br><span class=\"line\">            nums[idx++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"566-重塑矩阵\"><a href=\"#566-重塑矩阵\" class=\"headerlink\" title=\"566. 重塑矩阵\"></a><a href=\"https://leetcode-cn.com/problems/reshape-the-matrix/\">566. 重塑矩阵</a></h4><p>难度：简单</p>\n<p>在MATLAB中，有一个非常有用的函数 <code>reshape</code>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p>\n<p>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。</p>\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。</p>\n<p>如果具有给定参数的<code>reshape</code>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">nums = </span><br><span class=\"line\">[[1,2],</span><br><span class=\"line\"> [3,4]]</span><br><span class=\"line\">r = 1, c = 4</span><br><span class=\"line\">输出: </span><br><span class=\"line\">[[1,2,3,4]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">nums = </span><br><span class=\"line\">[[1,2],</span><br><span class=\"line\"> [3,4]]</span><br><span class=\"line\">r = 2, c = 4</span><br><span class=\"line\">输出: </span><br><span class=\"line\">[[1,2],</span><br><span class=\"line\"> [3,4]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意：</strong></p>\n<ol>\n<li>给定矩阵的宽和高范围在 [1, 100]。</li>\n<li>给定的 r 和 c 都是正数。</li>\n</ol>\n<p><strong>解析;</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/reshape-the-matrix/solution/zhong-su-ju-zhen-by-leetcode-solution-gt0g/\">重塑矩阵 - 重塑矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[][] matrixReshape(<span class=\"keyword\">int</span>[][] mat, <span class=\"keyword\">int</span> r, <span class=\"keyword\">int</span> c) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = mat.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = mat[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(m*n != r*c) <span class=\"keyword\">return</span> mat;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[][] reshapeMat = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[r][c];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ;i&lt;r;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;j&lt;c;j++)&#123;</span><br><span class=\"line\">                reshapeMat[i][j] = mat[index/n][index % n];<span class=\"comment\">//相当于把二维数组映射为一维数组，然后再映射回二维数组</span></span><br><span class=\"line\">                index++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> reshapeMat;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"485-最大连续-1-的个数\"><a href=\"#485-最大连续-1-的个数\" class=\"headerlink\" title=\"485. 最大连续 1 的个数\"></a><a href=\"https://leetcode-cn.com/problems/max-consecutive-ones/\">485. 最大连续 1 的个数</a></h4><p>难度：简单</p>\n<p>给定一个二进制数组， 计算其中最大连续 1 的个数。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[1,1,0,1,1,1]</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>输入的数组只包含 <code>0</code> 和 <code>1</code> 。</li>\n<li>输入数组的长度是正整数，且不超过 10,000。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/max-consecutive-ones/solution/zui-da-lian-xu-1de-ge-shu-by-leetcode-so-252a/\">最大连续1的个数 - 最大连续 1 的个数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findMaxConsecutiveOnes</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> max = <span class=\"number\">0</span>,cur = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums)&#123;</span><br><span class=\"line\">            cur = num == <span class=\"number\">0</span>? <span class=\"number\">0</span> : (cur +<span class=\"number\">1</span>);</span><br><span class=\"line\">            max = Math.max(max,cur);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"240-搜索二维矩阵-II\"><a href=\"#240-搜索二维矩阵-II\" class=\"headerlink\" title=\"240. 搜索二维矩阵 II\"></a><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">240. 搜索二维矩阵 II</a></h4><p>难度：中等</p>\n<p>编写一个高效的算法来搜索 <code>*m* x *n*</code> 矩阵 <code>matrix</code> 中的一个目标值 <code>target</code> 。该矩阵具有以下特性：</p>\n<ul>\n<li>每行的元素从左到右升序排列。</li>\n<li>每列的元素从上到下升序排列。</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= n, m &lt;= 300</code></li>\n<li><code>-109 &lt;= matix[i][j] &lt;= 109</code></li>\n<li>每行的所有元素从左到右升序排列</li>\n<li>每列的所有元素从上到下升序排列</li>\n<li><code>-109 &lt;= target &lt;= 109</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/sou-suo-er-wei-ju-zhen-ii-by-leetcode-2/\">搜索二维矩阵 II - 搜索二维矩阵 II - 力扣（LeetCode） (leetcode-cn.com)</a> 方法四</p>\n<p>这里是对“方法四”的“如何选出发点”的补充：</p>\n<ul>\n<li>选左上角，往右走和往下走都增大，不能选</li>\n<li>选右下角，往上走和往左走都减小，不能选</li>\n<li>选左下角，往右走增大，往上走减小，可选</li>\n<li>选右上角，往下走增大，往左走减小，可选</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 以右上角的数字为准，跟target比较，决定是排除列还是行</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = n - <span class=\"number\">1</span>;   <span class=\"comment\">// 从第一行，最后一列开始搜索</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &gt;= <span class=\"number\">0</span> &amp;&amp; j &gt;= <span class=\"number\">0</span> &amp;&amp; i &lt; m &amp;&amp; j &lt; n) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> num = matrix[i][j];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (num == target) &#123;   <span class=\"comment\">// 第1种情况: 查找成功</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (num &gt; target) &#123;  <span class=\"comment\">// 第2种情况: 当前列的元素都比目标大，可排除当前列</span></span><br><span class=\"line\">                j--;    <span class=\"comment\">// 排除当前列</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;    <span class=\"comment\">// 第3种情况: 当前行的元素都比目标小，可排除当前行</span></span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>自己写法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">searchMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(matrix == <span class=\"keyword\">null</span> || matrix.length==<span class=\"number\">0</span> || matrix[<span class=\"number\">0</span>].length == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length,n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = <span class=\"number\">0</span> ,col = n-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(row &lt; m &amp;&amp; col &gt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[row][col] == target) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((target &lt; matrix[row][col])) col--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> row++;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n<h4 id=\"378-有序矩阵中第-K-小的元素\"><a href=\"#378-有序矩阵中第-K-小的元素\" class=\"headerlink\" title=\"378. 有序矩阵中第 K 小的元素\"></a><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/\">378. 有序矩阵中第 K 小的元素</a></h4><p>难度：中等</p>\n<p>给你一个 <code>n x n</code> 矩阵 <code>matrix</code> ，其中每行和每列元素均按升序排序，找到矩阵中第 <code>k</code> 小的元素。<br>请注意，它是 <strong>排序后</strong> 的第 <code>k</code> 小元素，而不是第 <code>k</code> 个 <strong>不同</strong> 的元素。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span><br><span class=\"line\">输出：13</span><br><span class=\"line\">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[-5]], k = 1</span><br><span class=\"line\">输出：-5</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= n &lt;= 300</code></li>\n<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>\n<li>题目数据 <strong>保证</strong> <code>matrix</code> 中的所有行和列都按 <strong>非递减顺序</strong> 排列</li>\n<li><code>1 &lt;= k &lt;= n2</code></li>\n</ul>\n<p><strong>解析</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/378java-er-fen-fa-tu-jie-you-xian-dui-lie-liang-ch/\">378.java 二分法（图解）/优先队列 两种方法详解 - 有序矩阵中第 K 小的元素 - 力扣（LeetCode） (leetcode-cn.com)</a> 方法二</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = matrix.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = matrix[n-<span class=\"number\">1</span>][n-<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(left &lt; right)&#123;<span class=\"comment\">//这里一般题目二分查找是left &lt;= right 但该题是为了返回左边界</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = left + ((right - left)&gt;&gt;<span class=\"number\">1</span>);<span class=\"comment\">//等同于(left + right-left + left)/2 即防止left + right 溢出</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(check(matrix,mid,k,n))&#123;</span><br><span class=\"line\">                right = mid;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                left = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix,<span class=\"keyword\">int</span> mid,<span class=\"keyword\">int</span> k,<span class=\"keyword\">int</span> n)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = n-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//第n-1行第0列  从左下角出发</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&gt;=<span class=\"number\">0</span> &amp;&amp; j &lt; n)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(matrix[i][j] &lt;= mid)&#123;</span><br><span class=\"line\">                num += i+<span class=\"number\">1</span>;<span class=\"comment\">//该行前面的数都是小于mid的数，+1是因为加上本身也属于</span></span><br><span class=\"line\">                j++;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                i--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> num&gt;=k;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>关于<strong>二分查找返回的left一定在矩阵中</strong>这个问题, 写一点个人的理解.<br>可以参考34. 在排序数组中查找元素的第一个和最后一个位置.<a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">我们先看check函数.check函数的目的是统计矩阵里小等于mid的元素数目count. 再判断count和k的关系.因为mid = (l + r) / <span class=\"number\">2</span>这种划分方法是把矩阵划分成了[left , mid] 与[mid + <span class=\"number\">1</span>, right]两部分. 当 count &lt; k 时, 说明mid太小了, 我们应该在[mid + <span class=\"number\">1</span>, right] 这个范围里查找. 否则在[left, mid]范围里查找.</span><br><span class=\"line\">如果存在一个不在矩阵中的数a满足条件, 因为a不在矩阵中,那count统计的元素肯定都是小于a的, 那一定存在一个比a小且在矩阵中的数b满足条件,即从小于a的数变成了小于等于b的数 .等用题目中的例子,x = <span class=\"number\">13</span> 和x = <span class=\"number\">14</span> 都满足小于等于x的元素数目等于<span class=\"number\">8</span>, 对<span class=\"number\">14</span>来说统计的都是小于它的数, 而对<span class=\"number\">13</span>来说统计的都是小于等于它的数. 问题来了, 那为何取到的不是<span class=\"number\">14</span>而是<span class=\"number\">13</span>呢?</span><br><span class=\"line\"></span><br><span class=\"line\">因为我们取mid的取法是 mid = (left + right) / <span class=\"number\">2</span>, 当left &lt; right时, mid 永远 取不到right, 想要mid取到right ,只有left == right. 但循环条件是 <span class=\"keyword\">while</span>(left &lt; right),当 left == right时循环已经终止. 所以我们得到会是一个左边界. 还是用题目中的例子, 假设left = <span class=\"number\">13</span>, right = <span class=\"number\">14</span> 则 mid = (<span class=\"number\">13</span> + <span class=\"number\">14</span>) / <span class=\"number\">2</span> = <span class=\"number\">13</span></span><br></pre></td></tr></table></figure>\n\n<p>另一种解法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> lo = matrix[<span class=\"number\">0</span>][<span class=\"number\">0</span>], hi = matrix[m - <span class=\"number\">1</span>][n - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (lo &lt;= hi) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cnt &lt; k) lo = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> hi = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lo;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"645-错误的集合\"><a href=\"#645-错误的集合\" class=\"headerlink\" title=\"645. 错误的集合\"></a><a href=\"https://leetcode-cn.com/problems/set-mismatch/\">645. 错误的集合</a></h4><p>难度：简单</p>\n<p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p>\n<p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p>\n<p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,2,4]</span><br><span class=\"line\">输出：[2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 104</code></li>\n<li><code>1 &lt;= nums[i] &lt;= 104</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/\">【宫水三叶】一题三解：「计数」&amp;「数学」&amp;「桶排序」 - 错误的集合 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/set-mismatch/solution/javasan-chong-jie-fa-by-wwwhang-bqky/\">Java三种解法 hash 鸽巢原理 原地算法 - 错误的集合 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findErrorNums(<span class=\"keyword\">int</span>[] nums) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nums[i] != i+<span class=\"number\">1</span> &amp;&amp; nums[i] != nums[nums[i]-<span class=\"number\">1</span>])&#123;</span><br><span class=\"line\">                swap(nums,i,nums[i]-<span class=\"number\">1</span>);<span class=\"comment\">//这里i与nums[i] -1 都是索引  即对于每一个数字nums[i]：移动到nums[nums[i] - 1]。这样，每个数字都可以移动到正确的地方。</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">         <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ;i&lt; nums.length;i++)&#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span>(nums[i] != i +<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                 <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;nums[i],i+<span class=\"number\">1</span>&#125;;</span><br><span class=\"line\">             &#125;</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;              </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">swap</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> i,<span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = nums[i];</span><br><span class=\"line\">        nums[i] = nums[j];</span><br><span class=\"line\">        nums[j] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/users/yukkkino/avatar_1616732979.png\" alt=\"Yukkkino\"></p>\n<p><strong>解释</strong></p>\n<ol>\n<li>因为集合s包含1到n的整数，那么数组中的某个元素值恒等于索引值+1。可以使用计数，把每个元素出现的次数记录下来，遍历次数数组一遍即可知道哪些数字出现了，哪些没出现。</li>\n<li>有一个常用的方法是，将元素 i + 1 存放到数组下标索引 i 中去，即做一个索引到元素值的映射（i -&gt; i + 1）。 那么我们就需要满足这样性质的数组：</li>\n</ol>\n<figure class=\"highlight prolog\"><table><tr><td class=\"code\"><pre><span class=\"line\">nums[i] = i+<span class=\"number\">1</span>    →    i = nums[i]−<span class=\"number\">1</span>    →    nums[i] = nums[nums[i]−<span class=\"number\">1</span>]</span><br></pre></td></tr></table></figure>\n\n<p>因此，要先对数组做一下处理，把每个元素i移动到数组下标i-1的地方去。 最后，每一个元素都交换到了它对应的位置，那必然会导致某个索引i，不满足nums[i]=i+1，这个nums[i] 就是我们要找的重复数。当nums[i] 是重复数时，根据数组的性质， 索引i存放的元素为i+1，但此时存放着的是重复数，所以缺少的数字就是i+1。</p>\n<h4 id=\"287-寻找重复数\"><a href=\"#287-寻找重复数\" class=\"headerlink\" title=\"287. 寻找重复数\"></a><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/\">287. 寻找重复数</a></h4><p>难度：中等</p>\n<p>给定一个包含 <code>n + 1</code> 个整数的数组 <code>nums</code> ，其数字都在 <code>1</code> 到 <code>n</code> 之间（包括 <code>1</code> 和 <code>n</code>），可知至少存在一个重复的整数。</p>\n<p>假设 <code>nums</code> 只有 <strong>一个重复的整数</strong> ，找出 <strong>这个重复的数</strong> 。</p>\n<p>你设计的解决方案必须不修改数组 <code>nums</code> 且只用常量级 <code>O(1)</code> 的额外空间。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3,4,2,2]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,1,3,4,2]</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,1,2]</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 105</code></li>\n<li><code>nums.length == n + 1</code></li>\n<li><code>1 &lt;= nums[i] &lt;= n</code></li>\n<li><code>nums</code> 中 <strong>只有一个整数</strong> 出现 <strong>两次或多次</strong> ，其余整数均只出现 <strong>一次</strong></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>如何证明 <code>nums</code> 中至少存在一个重复的数字?</li>\n<li>你可以设计一个线性级时间复杂度 <code>O(n)</code> 的解决方案吗？</li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p><a href=\"https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/\">使用二分法查找一个有范围的整数（结合抽屉原理） - 寻找重复数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// int n = nums;</span></span><br><span class=\"line\">        <span class=\"comment\">// int[] cnts = new int[n+1];</span></span><br><span class=\"line\">        <span class=\"comment\">// int sum = 0,set = 0;</span></span><br><span class=\"line\">        <span class=\"comment\">// for(int num : nums)&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">//     sum += num;</span></span><br><span class=\"line\">        <span class=\"comment\">//     if(cnts[num] == 0) set += num;</span></span><br><span class=\"line\">        <span class=\"comment\">//     cnts[num] = 1; </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">        <span class=\"comment\">// return  sum -set;</span></span><br><span class=\"line\">        <span class=\"comment\">// 以上方法不行 不通过案例 输入：[2,2,2,2,2] 输出：8 预期结果：2</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> l = <span class=\"number\">1</span>,h = nums.length-<span class=\"number\">1</span>;<span class=\"comment\">//这里是1到n的数</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l&lt;=h)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> mid = l + (h -l)/<span class=\"number\">2</span>;<span class=\"comment\">//这里注意不能写成1+(h-l)&gt;&gt;1,要写成l+((h-l)&gt;&gt;1)</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt; nums.length;i++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[i] &lt;= mid) cnt++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cnt &gt; mid) h = mid-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid +<span class=\"number\">1</span>; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>二分查找知识讲解：</strong></p>\n<p><a href=\"https://www.cnblogs.com/kyoner/p/11080078.html\">详解二分查找算法 - murphy_gb - 博客园 (cnblogs.com)</a></p>\n<p><strong>快慢指针代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findDuplicate</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fast = <span class=\"number\">0</span>, slow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">do</span>&#123;</span><br><span class=\"line\">            fast = nums[nums[fast]];<span class=\"comment\">// fast每次走两步</span></span><br><span class=\"line\">            slow = nums[slow];<span class=\"comment\">// slow每次走一步</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">while</span> (fast != slow);<span class=\"comment\">// 直至二者相遇，即fast比slow多走了一圈，slow走了一圈，fast走了两圈，逻辑上不会走第三圈</span></span><br><span class=\"line\"></span><br><span class=\"line\">        fast = <span class=\"number\">0</span>;<span class=\"comment\">// 节约空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (fast != slow)&#123;<span class=\"comment\">// 直到二者相遇</span></span><br><span class=\"line\">            fast = nums[fast];</span><br><span class=\"line\">            slow = nums[slow];</span><br><span class=\"line\">            <span class=\"comment\">// 二者皆移动一次</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;<span class=\"comment\">// 即我们找到的起点，重复的点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>快慢指针证明</p>\n<p>![img](file:///C:\\Users\\Wanan\\Documents\\Tencent Files\\1210435820\\Image\\C2C\\NN{FAG@]0GG6Y~TGE0XYWNH.png)</p>\n<h4 id=\"667-优美的排列-II\"><a href=\"#667-优美的排列-II\" class=\"headerlink\" title=\"667. 优美的排列 II\"></a><a href=\"https://leetcode-cn.com/problems/beautiful-arrangement-ii/\">667. 优美的排列 II</a></h4><p>难度：中等</p>\n<p>给你两个整数 <code>n</code> 和 <code>k</code> ，请你构造一个答案列表 <code>answer</code> ，该列表应当包含从 <code>1</code> 到 <code>n</code> 的 <code>n</code> 个不同正整数，并同时满足下述条件：</p>\n<ul>\n<li>假设该列表是 <code>answer = [a1, a2, a3, ... , an]</code> ，那么列表 <code>[|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|]</code> 中应该有且仅有 <code>k</code> 个不同整数。</li>\n</ul>\n<p>返回列表 <code>answer</code> 。如果存在多种答案，只需返回其中 <strong>任意一种</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 1</span><br><span class=\"line\">输出：[1, 2, 3]</span><br><span class=\"line\">解释：[1, 2, 3] 包含 3 个范围在 1-3 的不同整数，并且 [1, 1] 中有且仅有 1 个不同整数：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3, k = 2</span><br><span class=\"line\">输出：[1, 3, 2]</span><br><span class=\"line\">解释：[1, 3, 2] 包含 3 个范围在 1-3 的不同整数，并且 [2, 1] 中有且仅有 2 个不同整数：1 和 2</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= k &lt; n &lt;= 104</code></li>\n</ul>\n<p> <strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] constructArray(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> k) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];</span><br><span class=\"line\">        res[<span class=\"number\">0</span>] = <span class=\"number\">1</span> ;</span><br><span class=\"line\">        <span class=\"comment\">//让前k+1个元素构造出 k 个不同的差值 ，序列为 1,k+1,2,k,3,k-1,...,k/2,k/2+1</span></span><br><span class=\"line\">        <span class=\"comment\">//比如这里n=6，k=3 那么前4个元素构造成3个不同的差值  即前四个元素为 1 4 2 3  差值为 3 2 1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i  =<span class=\"number\">1</span> ,val = k;i&lt;=k;i++,val--)&#123;</span><br><span class=\"line\">            res[i] = i%<span class=\"number\">2</span>==<span class=\"number\">1</span> ? res[i-<span class=\"number\">1</span>] + val : res[i-<span class=\"number\">1</span>] - val;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//构造后面n-(k+1)个元素 这里接着上面的  1 4 2 3 添加 5 6  构造成 1 4 2 3 5 6</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = k+<span class=\"number\">1</span>;i&lt;n;i++)&#123;</span><br><span class=\"line\">            res[i] = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;<span class=\"comment\">//返回数组   这道题感觉是一个找规律的题  找不出来不必纠结</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"697-数组的度\"><a href=\"#697-数组的度\" class=\"headerlink\" title=\"697. 数组的度\"></a><a href=\"https://leetcode-cn.com/problems/degree-of-an-array/\">697. 数组的度</a></h4><p>难度：简单</p>\n<p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p>\n<p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[1, 2, 2, 3, 1]</span><br><span class=\"line\">输出：2</span><br><span class=\"line\">解释：</span><br><span class=\"line\">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class=\"line\">连续子数组里面拥有相同度的有如下所示:</span><br><span class=\"line\">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class=\"line\">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[1,2,2,3,1,4,2]</span><br><span class=\"line\">输出：6</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>nums.length</code> 在1到 50,000 区间范围内。</li>\n<li><code>nums[i]</code> 是一个在 0 到 49,999 范围内的整数。</li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/degree-of-an-array/solution/yi-ci-shu-zu-bian-li-ha-xi-biao-by-dong-d9lvg/\">一次数组遍历 + 哈希表 - 数组的度 - 力扣（LeetCode） (leetcode-cn.com)</a> 方法二</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findShortestSubArray</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> len = nums.length,maxCount = <span class=\"number\">0</span>,minWindow = <span class=\"number\">0</span>;</span><br><span class=\"line\">        Map&lt;Integer,<span class=\"keyword\">int</span>[]&gt; map = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span> ;i &lt; len;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span>[] pair = map.get(nums[i]);<span class=\"comment\">// pair数组 表示 pair[0]记录每个元素第一次出现的位置，pair[1]表示当前出现了几次</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pair == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                pair = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[]&#123;i,<span class=\"number\">1</span>&#125;;<span class=\"comment\">//i 即当前出现的位置， 1表示出现次数</span></span><br><span class=\"line\">                map.put(nums[i],pair);</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                pair[<span class=\"number\">1</span>]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(pair[<span class=\"number\">1</span>] &gt; maxCount)&#123;</span><br><span class=\"line\">                maxCount = pair[<span class=\"number\">1</span>];</span><br><span class=\"line\">                minWindow = i - pair[<span class=\"number\">0</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pair[<span class=\"number\">1</span>] == maxCount)&#123;</span><br><span class=\"line\">                minWindow = Math.min(minWindow,i-pair[<span class=\"number\">0</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minWindow;               </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"766-托普利茨矩阵\"><a href=\"#766-托普利茨矩阵\" class=\"headerlink\" title=\"766. 托普利茨矩阵\"></a><a href=\"https://leetcode-cn.com/problems/toeplitz-matrix/\">766. 托普利茨矩阵</a></h4><p>难度：简单</p>\n<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p>\n<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class=\"line\">输出：true</span><br><span class=\"line\">解释：</span><br><span class=\"line\">在上述矩阵中, 其对角线为: </span><br><span class=\"line\">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class=\"line\">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：matrix = [[1,2],[2,2]]</span><br><span class=\"line\">输出：false</span><br><span class=\"line\">解释：</span><br><span class=\"line\">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == matrix.length</code></li>\n<li><code>n == matrix[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 20</code></li>\n<li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>如果矩阵存储在磁盘上，并且内存有限，以至于一次最多只能将矩阵的一行加载到内存中，该怎么办？</li>\n<li>如果矩阵太大，以至于一次只能将不完整的一行加载到内存中，该怎么办？</li>\n</ul>\n<p><strong>解析</strong>:</p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/toeplitz-matrix/solution/cong-ci-pan-du-qu-cheng-ben-fen-xi-liang-f20w/\">从磁盘读取成本分析两种 100% 遍历思路：按格子遍历 &amp; 按线遍历 - 托普利茨矩阵 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isToeplitzMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length,n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">1</span>; i &lt; m ; i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;j&lt;n;j++)&#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(matrix[i][j] != matrix[i-<span class=\"number\">1</span>][j-<span class=\"number\">1</span>]) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>对解析来源中的第二种方法进行修改</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isToeplitzMatrix</span><span class=\"params\">(<span class=\"keyword\">int</span>[][] matrix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m = matrix.length, n = matrix[<span class=\"number\">0</span>].length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> row = m, col = n;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (col-- &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, j = col, val = matrix[i++][j++]; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] != val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (--row &gt; <span class=\"number\">0</span>) &#123;<span class=\"comment\">//while循环改成--row好一点，如果是row-- 就会对题目中的示例1中 1 1 1 这条对角线访问两次</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = row, j = <span class=\"number\">0</span>, val = matrix[i++][j++]; i &lt; m &amp;&amp; j &lt; n; i++, j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (matrix[i][j] != val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"565-数组嵌套\"><a href=\"#565-数组嵌套\" class=\"headerlink\" title=\"565. 数组嵌套\"></a><a href=\"https://leetcode-cn.com/problems/array-nesting/\">565. 数组嵌套</a></h4><p>难度：中等</p>\n<p>索引从<code>0</code>开始长度为<code>N</code>的数组<code>A</code>，包含<code>0</code>到<code>N - 1</code>的所有整数。找到最大的集合<code>S</code>并返回其大小，其中 <code>S[i] = &#123;A[i], A[A[i]], A[A[A[i]]], ... &#125;</code>且遵守以下的规则。</p>\n<p>假设选择索引为<code>i</code>的元素<code>A[i]</code>为<code>S</code>的第一个元素，<code>S</code>的下一个元素应该是<code>A[A[i]]</code>，之后是<code>A[A[A[i]]]...</code> 以此类推，不断添加直到<code>S</code>出现重复的元素。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: A = [5,4,0,3,1,6,2]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释: </span><br><span class=\"line\">A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</span><br><span class=\"line\"></span><br><span class=\"line\">其中一种最长的 S[K]:</span><br><span class=\"line\">S[0] = &#123;A[0], A[5], A[6], A[2]&#125; = &#123;5, 6, 2, 0&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ol>\n<li><code>N</code>是<code>[1, 20,000]</code>之间的整数。</li>\n<li><code>A</code>中不含有重复的元素。</li>\n<li><code>A</code>中的元素大小在<code>[0, N-1]</code>之间</li>\n</ol>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/array-nesting/solution/javaqiu-jie-de-si-kao-yu-gai-jin-by-zackqf/\">Java求解方法的思考与改进 - 数组嵌套 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">arrayNesting</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> count =<span class=\"number\">0</span> ,k = i;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(nums[k] != -<span class=\"number\">1</span>)&#123;<span class=\"comment\">//知道访问到-1 说明重复访问</span></span><br><span class=\"line\">                count++;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> temp = nums[k];</span><br><span class=\"line\">                nums[k] = -<span class=\"number\">1</span>;<span class=\"comment\">//访问过的数用-1标记</span></span><br><span class=\"line\">                k = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            res  = Math.max(res,count);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"769-最多能完成排序的块\"><a href=\"#769-最多能完成排序的块\" class=\"headerlink\" title=\"769. 最多能完成排序的块\"></a><a href=\"https://leetcode-cn.com/problems/max-chunks-to-make-sorted/\">769. 最多能完成排序的块</a></h4><p>难度：中等</p>\n<p>数组<code>arr</code>是<code>[0, 1, ..., arr.length - 1]</code>的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>\n<p>我们最多能将数组分成多少块？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: arr = [4,3,2,1,0]</span><br><span class=\"line\">输出: 1</span><br><span class=\"line\">解释:</span><br><span class=\"line\">将数组分成2块或者更多块，都无法得到所需的结果。</span><br><span class=\"line\">例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: arr = [1,0,2,3,4]</span><br><span class=\"line\">输出: 4</span><br><span class=\"line\">解释:</span><br><span class=\"line\">我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。</span><br><span class=\"line\">然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong></p>\n<ul>\n<li><code>arr</code> 的长度在 <code>[1, 10]</code> 之间。</li>\n<li><code>arr[i]</code>是 <code>[0, 1, ..., arr.length - 1]</code>的一种排列。</li>\n</ul>\n<p><strong>解析</strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxChunksToSorted</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// 从前往后遍历，和排序后的数组对比，决定可分割位置的是各个无序子序列的最大元素，若子序列排序后最大元素==下标idx值，由于所有元素都在子序列范围内唯一，代表排序后子序列元素能和下标一一对应，</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(arr == <span class=\"keyword\">null</span> ) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>,max = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt; arr.length;i++)&#123;</span><br><span class=\"line\">            max = Math.max(max,arr[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(max == i) res++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"8.位运算","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/8-%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"<h4 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a><strong>原理</strong></h4><p><strong>基本原理</strong></p>\n<p>0s 表示一串 0，1s 表示一串 1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">x ^ 0s = x      x &amp; 0s = 0      x | 0s = x</span><br><span class=\"line\">x ^ 1s = ~x     x &amp; 1s = x      x | 1s = 1s</span><br><span class=\"line\">x ^ x = 0       x &amp; x = x       x | x = x</span><br></pre></td></tr></table></figure>\n\n<p>利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转；利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1^1^2 = 2</span><br></pre></td></tr></table></figure>\n\n<p>利用 x &amp; 0s = 0 和 x &amp; 1s = x 的特点，可以实现掩码操作。一个数 num 与 mask：00111100 进行位与操作，只保留 num 中与 mask 的 1 部分相对应的位。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00011000</span><br></pre></td></tr></table></figure>\n\n<p>利用 x | 0s = x 和 x | 1s = 1s 的特点，可以实现设值操作。一个数 num 与 mask：00111100 进行位或操作，将 num 中与 mask 的 1 部分相对应的位都设置为 1。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 |</span><br><span class=\"line\">00111100</span><br><span class=\"line\">--------</span><br><span class=\"line\">01111111</span><br></pre></td></tr></table></figure>\n\n<p><strong>位与运算技巧</strong></p>\n<p>n&amp;(n-1) 去除 n 的位级表示中最低的那一位 1。例如对于二进制表示 01011011，减去 1 得到 01011010，这两个数相与得到 01011010。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">01011011 &amp;</span><br><span class=\"line\">01011010</span><br><span class=\"line\">--------</span><br><span class=\"line\">01011010</span><br></pre></td></tr></table></figure>\n\n<p>n&amp;(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">10110100 &amp;</span><br><span class=\"line\">01001100</span><br><span class=\"line\">--------</span><br><span class=\"line\">00000100</span><br></pre></td></tr></table></figure>\n\n<p>n-(n&amp;(-n)) 则可以去除 n 的位级表示中最低的那一位 1，和 n&amp;(n-1) 效果一样。</p>\n<p><strong>移位运算</strong></p>\n<p>&gt;&gt; n 为算术右移，相当于除以 2n，例如 -7 &gt;&gt; 2 = -2。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">11111111111111111111111111111110</span><br></pre></td></tr></table></figure>\n\n<p>&gt;&gt;&gt; n 为无符号右移，左边会补上 0。例如 -7 &gt;&gt;&gt; 2 = 1073741822。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &gt;&gt;&gt; 2</span><br><span class=\"line\">--------</span><br><span class=\"line\">00111111111111111111111111111111</span><br></pre></td></tr></table></figure>\n\n<p>&lt;&lt; n 为算术左移，相当于乘以 2n。-7 &lt;&lt; 2 = -28。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">11111111111111111111111111111001  &lt;&lt; 2--------11111111111111111111111111100100</span><br></pre></td></tr></table></figure>\n\n<p><strong>mask 计算</strong></p>\n<p>要获取 111111111，将 0 取反即可，~0。</p>\n<p>要得到只有第 i 位为 1 的 mask，将 1 向左移动 i-1 位即可，1&lt;&lt;(i-1) 。例如 1&lt;&lt;4 得到只有第 5 位为 1 的 mask ：00010000。</p>\n<p>要得到 1 到 i 位为 1 的 mask，(1&lt;&lt;i)-1 即可，例如将 (1&lt;&lt;4)-1 = 00010000-1 = 00001111。</p>\n<p>要得到 1 到 i 位为 0 的 mask，只需将 1 到 i 位为 1 的 mask 取反，即 ~((1&lt;&lt;i)-1)。</p>\n<p><strong>Java 中的位操作</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">static int Integer.bitCount();           // 统计 1 的数量static int Integer.highestOneBit();      // 获得最高位static String toBinaryString(int i);     // 转换为二进制表示的字符串</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"461-汉明距离\"><a href=\"#461-汉明距离\" class=\"headerlink\" title=\"461. 汉明距离\"></a><a href=\"https://leetcode-cn.com/problems/hamming-distance/\">461. 汉明距离</a></h4><p>难度：简单</p>\n<p>两个整数之间的 <a href=\"https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB\">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。</p>\n<p>给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = 1, y = 4输出：2解释：1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：x = 3, y = 1输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>0 &lt;= x, y &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/hamming-distance/solution/yi-ming-ju-chi-by-leetcode-solution-u1w7/\">汉明距离 - 汉明距离 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;        <span class=\"keyword\">int</span> z = x^y;        <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;        <span class=\"keyword\">while</span>(z!= <span class=\"number\">0</span>)&#123;            <span class=\"keyword\">if</span>((z&amp;<span class=\"number\">1</span>) == <span class=\"number\">1</span>) count++;            z = z &gt;&gt; <span class=\"number\">1</span>;        &#125;        <span class=\"keyword\">return</span> count;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"136-只出现一次的数字\"><a href=\"#136-只出现一次的数字\" class=\"headerlink\" title=\"136. 只出现一次的数字\"></a><a href=\"https://leetcode-cn.com/problems/single-number/\">136. 只出现一次的数字</a></h4><p>难度：简单</p>\n<p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p>\n<p><strong>说明：</strong></p>\n<p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [2,2,1]输出: 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [4,1,2,1,2]输出: 4</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums)&#123;            ret = num ^ ret;        &#125;        <span class=\"keyword\">return</span> ret;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"268-丢失的数字\"><a href=\"#268-丢失的数字\" class=\"headerlink\" title=\"268. 丢失的数字\"></a><a href=\"https://leetcode-cn.com/problems/missing-number/\">268. 丢失的数字</a></h4><p>难度：简单</p>\n<p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</li>\n</ul>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [3,0,1]输出：2解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,1]输出：2解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [9,6,4,2,3,5,7,0,1]输出：8解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0]输出：1解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>n == nums.length</code></li>\n<li><code>1 &lt;= n &lt;= 104</code></li>\n<li><code>0 &lt;= nums[i] &lt;= n</code></li>\n<li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li>\n</ul>\n<p><strong>解析:</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/missing-number/solution/que-shi-shu-zi-by-leetcode/\">缺失数字 - 丢失的数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">missingNumber</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;        <span class=\"keyword\">int</span> length = nums.length;        <span class=\"keyword\">int</span> ret = <span class=\"number\">0</span>;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;length;i++)&#123;            ret = ret ^ i ^ nums[i];        &#125;        <span class=\"keyword\">return</span> ret ^ length;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"260-只出现一次的数字-III\"><a href=\"#260-只出现一次的数字-III\" class=\"headerlink\" title=\"260. 只出现一次的数字 III\"></a><a href=\"https://leetcode-cn.com/problems/single-number-iii/\">260. 只出现一次的数字 III</a></h4><p>难度：中等</p>\n<p>给定一个整数数组 <code>nums</code>，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 <strong>任意顺序</strong> 返回答案。</p>\n<p><strong>进阶：</strong>你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,2,1,3,2,5]输出：[3,5]解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [-1,0]输出：[-1,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [0,1]输出：[1,0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= nums.length &lt;= 3 * 104</code></li>\n<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>\n<li>除两个只出现一次的整数外，<code>nums</code> 中的其他数字都出现两次</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/single-number-iii/solution/javawei-yun-suan-jie-jue-ji-bai-liao-999-dp5b/\">Java位运算解决，击败了99.94%的用户 - 只出现一次的数字 III - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] singleNumber(<span class=\"keyword\">int</span>[] nums) &#123;        <span class=\"keyword\">int</span> diff = <span class=\"number\">0</span>;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : nums) diff ^= num;        diff = diff &amp; -diff;<span class=\"comment\">//得到最右一位        int[] ret = new int[2];        for(int num : nums)&#123;            if((diff &amp; num) == 0 )&#123;//根据最右一位来判断两个出现一次且不同的数                ret[0] ^= num;            &#125;else&#123;                ret[1] ^= num;            &#125;        &#125;        return ret;       &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"190-颠倒二进制位\"><a href=\"#190-颠倒二进制位\" class=\"headerlink\" title=\"190. 颠倒二进制位\"></a><a href=\"https://leetcode-cn.com/problems/reverse-bits/\">190. 颠倒二进制位</a></h4><p>难度：简单</p>\n<p>颠倒给定的 32 位无符号整数的二进制位。</p>\n<p><strong>提示：</strong></p>\n<ul>\n<li>请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。</li>\n<li>在 Java 中，编译器使用<a href=\"https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A5%E7%A0%81/5295284\">二进制补码</a>记法来表示有符号整数。因此，在上面的 <strong>示例 2</strong> 中，输入表示有符号整数 <code>-3</code>，输出表示有符号整数 <code>-1073741825</code>。</li>\n</ul>\n<p><strong>进阶</strong>:<br>如果多次调用这个函数，你将如何优化你的算法？</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 00000010100101000001111010011100输出: 00111001011110000010100101000000解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：11111111111111111111111111111101输出：10111111111111111111111111111111解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 00000010100101000001111010011100输出：964176192 (00111001011110000010100101000000)解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 11111111111111111111111111111101输出：3221225471 (10111111111111111111111111111111)解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>输入是一个长度为 <code>32</code> 的二进制字符串</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/reverse-bits/solution/4chong-jie-jue-fang-shi-tu-wen-xiang-jie-fsgg/\">4种解决方式，图文详解 - 颠倒二进制位 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>普通循环：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"comment\">// you need treat n as an unsigned value    public int reverseBits(int n) &#123;        int res  = 0;        for(int i = 0;i&lt;32;i++)&#123;            res &lt;&lt;= 1;            res += (n&amp;1);            n &gt;&gt;= 1;        &#125;        return res;                    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<p>因为题目是给的32位</p>\n<p>分治：<a href=\"https://leetcode-cn.com/problems/reverse-bits/solution/yi-tu-kan-dong-fen-zhi-fang-fa-qiu-jie-b-rbx9/\">一图看懂分治方法求解 - 颠倒二进制位 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">reverseBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;        n = (n &gt;&gt;&gt; <span class=\"number\">16</span>) | (n &lt;&lt; <span class=\"number\">16</span>);        n = ((n &amp; <span class=\"number\">0xff00ff00</span>) &gt;&gt;&gt; <span class=\"number\">8</span>) | ((n &amp; <span class=\"number\">0x00ff00ff</span>) &lt;&lt; <span class=\"number\">8</span>);        n = ((n &amp; <span class=\"number\">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class=\"number\">4</span>) | ((n &amp; <span class=\"number\">0x0f0f0f0f</span>) &lt;&lt; <span class=\"number\">4</span>);        n = ((n &amp; <span class=\"number\">0xcccccccc</span>) &gt;&gt;&gt; <span class=\"number\">2</span>) | ((n &amp; <span class=\"number\">0x33333333</span>) &lt;&lt; <span class=\"number\">2</span>);        n = ((n &amp; <span class=\"number\">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class=\"number\">1</span>) | ((n &amp; <span class=\"number\">0x55555555</span>) &lt;&lt; <span class=\"number\">1</span>);        <span class=\"keyword\">return</span> n;    &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-不用额外变量交换两个整数\"><a href=\"#6-不用额外变量交换两个整数\" class=\"headerlink\" title=\"6. 不用额外变量交换两个整数\"></a>6. 不用额外变量交换两个整数</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">a = a ^ b;b = a ^ b;a = a ^ b;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"231-2-的幂\"><a href=\"#231-2-的幂\" class=\"headerlink\" title=\"231. 2 的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-two/\">231. 2 的幂</a></h4><p>难度：简单</p>\n<p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1输出：true解释：20 = 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 16输出：true解释：24 = 16</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 4输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 5输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>-231 &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>进阶：</strong>你能够不使用循环/递归解决此问题吗？</p>\n<p><strong>解析：</strong></p>\n<p>二进制表示只有一个 1 存在。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfTwo</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; Integer.bitCount(n) == <span class=\"number\">1</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用 1000 &amp; 0111 == 0 这种性质，得到以下解法：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public boolean isPowerOfTwo(int n) &#123;    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"342-4的幂\"><a href=\"#342-4的幂\" class=\"headerlink\" title=\"342. 4的幂\"></a><a href=\"https://leetcode-cn.com/problems/power-of-four/\">342. 4的幂</a></h4><p>难度：简单</p>\n<p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>\n<p>整数 <code>n</code> 是 4 的幂次方需满足：存在整数 <code>x</code> 使得 <code>n == 4x</code></p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 16输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 5输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 1输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>-231 &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>进阶：</strong></p>\n<ul>\n<li>你能不使用循环或者递归来完成本题吗？</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/power-of-four/solution/4de-mi-by-leetcode-solution-b3ya/\">4的幂 - 4的幂 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPowerOfFour</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;        <span class=\"keyword\">return</span> n &gt; <span class=\"number\">0</span> &amp;&amp; (n &amp; (n - <span class=\"number\">1</span>)) == <span class=\"number\">0</span> &amp;&amp; (n &amp; <span class=\"number\">0xaaaaaaaa</span>) == <span class=\"number\">0</span>;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;    public boolean hasAlternatingBits(int n) &#123;        // 如 010101 右移一位得到 001010        // 二者异或之后得到011111  (这一步是关键,只有交替出现01，异或后才能得到结果0111111...11)        // 为了判断 异或后的结果是否满足(0111111...11)类型的结果        // 可以用如下方法，比如        // 011111 加上1 为100000        // 011111 与 100000按位相与 结果为000000 ， 也就是0;        int m = n ^ (n &gt;&gt; 1);        return (m &amp; (m + 1)) == 0;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"693-交替位二进制数\"><a href=\"#693-交替位二进制数\" class=\"headerlink\" title=\"693. 交替位二进制数\"></a><a href=\"https://leetcode-cn.com/problems/binary-number-with-alternating-bits/\">693. 交替位二进制数</a></h4><p>难度：简单</p>\n<p>给定一个正整数，检查它的二进制表示是否总是 0、1 交替出现：换句话说，就是二进制表示中相邻两位的数字永不相同。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 5输出：true解释：5 的二进制表示是：101</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 7输出：false解释：7 的二进制表示是：111.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 11输出：false解释：11 的二进制表示是：1011.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 10输出：true解释：10 的二进制表示是：1010.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：n = 3输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= n &lt;= 231 - 1</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/binary-number-with-alternating-bits/solution/binary-number-with-alternating-bits-by-ikaruga/\">【交替位二进制数】图解两行位运算 - 交替位二进制数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasAlternatingBits</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;        <span class=\"comment\">// 如 010101 右移一位得到 001010        // 二者异或之后得到011111  (这一步是关键,只有交替出现01，异或后才能得到结果0111111...11)        // 为了判断 异或后的结果是否满足(0111111...11)类型的结果        // 可以用如下方法，比如        // 011111 加上1 为100000        // 011111 与 100000按位相与 结果为000000 ， 也就是0;        int m = n ^ (n &gt;&gt; 1);        return (m &amp; (m + 1)) == 0;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"476-数字的补数\"><a href=\"#476-数字的补数\" class=\"headerlink\" title=\"476. 数字的补数\"></a><a href=\"https://leetcode-cn.com/problems/number-complement/\">476. 数字的补数</a></h4><p>难度：简单</p>\n<p>给你一个 <strong>正</strong> 整数 <code>num</code> ，输出它的补数。补数是对该数的二进制表示取反。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：num = 1输出：0解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>给定的整数 <code>num</code> 保证在 32 位带符号整数的范围内。</li>\n<li><code>num &gt;= 1</code></li>\n<li>你可以假定二进制数不包含前导零位。</li>\n<li>本题与 1009 <a href=\"https://leetcode-cn.com/problems/complement-of-base-10-integer/\">https://leetcode-cn.com/problems/complement-of-base-10-integer/</a> 相同</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>方法一：</p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/number-complement/solution/yi-huo-by-im-me/\">抑或 - 数字的补数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;<span class=\"keyword\">public</span>:    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;        <span class=\"keyword\">int</span> tmp = <span class=\"number\">1</span>;        <span class=\"keyword\">while</span> (tmp &lt; num)        &#123;            tmp &lt;&lt;= <span class=\"number\">1</span>;            tmp += <span class=\"number\">1</span>;        &#125;        <span class=\"keyword\">return</span> (tmp^num);    &#125;&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>方法二：</p>\n<p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findComplement</span><span class=\"params\">(<span class=\"keyword\">int</span> num)</span> </span>&#123;        <span class=\"keyword\">if</span>(num == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;        <span class=\"keyword\">int</span> mask = Integer.highestOneBit(num);<span class=\"comment\">//比如5的二进制是101 那么调用highestOneBit()看最高位 即 100        mask = (mask &lt;&lt; 1) -1 ;               //此时左移一位即 1000  再减一 得到 0111        return num ^ mask;                    //所以0101 ^ 0111 = 010    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">JDK的解析返回具有至多单个 1 位的 int 值，在指定的 int 值中最高位（最左边）的 1 位的位置。如果指定的值在其二进制补码表示形式中不具有 1 位，即它等于零，则返回零。简单的说法如果一个数是0, 则返回0；如果是负数, 则返回 -2147483648：【1000,0000,0000,0000,0000,0000,0000,0000】(二进制表示的数)；如果是正数, 返回的则是跟它最靠近的比它小的2的N次方比如 17：二进制是【0000,0000,0000,0000,0000,0000,0001,0001】highestOneBit(17)返回的是最高位的1个1, 其它全是0 的二进制数：【0000,0000,0000,0000,0000,0000,0001,0000】，其实就是16。</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"371-两整数之和\"><a href=\"#371-两整数之和\" class=\"headerlink\" title=\"371. 两整数之和\"></a><a href=\"https://leetcode-cn.com/problems/sum-of-two-integers/\">371. 两整数之和</a></h4><p>难度：中等</p>\n<p><strong>不使用</strong>运算符 <code>+</code> 和 <code>-</code> ，计算两整数 <code>a</code> 、<code>b</code> 之和。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: a = 1, b = 2输出: 3</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: a = -2, b = 3输出: 1</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析：</strong></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/sum-of-two-integers/solution/wei-yun-suan-xiang-jie-yi-ji-zai-python-zhong-xu-y/\">位运算详解以及在 Python 中需要的特殊处理 - 两整数之和 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p>\n<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span> </span>&#123;        <span class=\"keyword\">return</span> (b==<span class=\"number\">0</span>) ? a : getSum(a^b,(a&amp;b) &lt;&lt; <span class=\"number\">1</span>)   ;         &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"318-最大单词长度乘积\"><a href=\"#318-最大单词长度乘积\" class=\"headerlink\" title=\"318. 最大单词长度乘积\"></a><a href=\"https://leetcode-cn.com/problems/maximum-product-of-word-lengths/\">318. 最大单词长度乘积</a></h4><p>难度：中等</p>\n<p>给定一个字符串数组 <code>words</code>，找到 <code>length(word[i]) * length(word[j])</code> 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]输出: 16 解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]输出: 4 解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]输出: 0 解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>2 &lt;= words.length &lt;= 1000</code></li>\n<li><code>1 &lt;= words[i].length &lt;= 1000</code></li>\n<li><code>words[i]</code> 仅包含小写字母</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>来源链接：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(String[] words)</span> </span>&#123;        <span class=\"keyword\">int</span> n  = words.length;        <span class=\"keyword\">int</span>[] val = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i&lt;n;i++)&#123;            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c : words[i].toCharArray())&#123;                val[i] |= <span class=\"number\">1</span>&lt;&lt;(c - <span class=\"string\">&#x27;a&#x27;</span>);            &#125;        &#125;         <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;n;i++)&#123;            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j = i +<span class=\"number\">1</span>;j &lt; n;j++)&#123;                <span class=\"keyword\">if</span>((val[i] &amp; val[j]) == <span class=\"number\">0</span>)&#123;                    res = Math.max(res,words[i].length() * words[j].length());                &#125;            &#125;        &#125;        <span class=\"keyword\">return</span> res;           &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p>详细解释版</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** * 解决方案： * 1. int的位数是32位，小写字母是26位，可以将小写字母的数字映射到比特位的对应的位置上（如z为26则映射到右到左第26位比特位为1），对应的字符串对应着32位比特位中的数个1，重复的字符不影响，因为只需要判断字符存在于另一字符串与否 * 2. 当str1与str2对应的32位比特，进行与运算，如为0说明没有对应字符位双方都为1，则可保存【最大单词长度乘积】 * 方法一：位运算——与运算 * Java：97% 65% * 复杂度：O(n^2) O(n) */</span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxProduct</span><span class=\"params\">(String[] words)</span> </span>&#123;        <span class=\"keyword\">int</span> n = words.length;        <span class=\"keyword\">int</span>[] bitWords = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n];        <span class=\"comment\">//(1)遍历每个word：将每个word对应的字符映射到bit上，如z为从右往左数第26位        for (int i = 0; i &lt; n; i++) &#123;            String word = words[i];            //存放bit的32位整数容器            int bitWord = 0;            //(1.1)遍历每个字母，放入bitWord中            for (int j = 0; j &lt; word.length(); j++) &#123;                bitWord |= (1 &lt;&lt; (word.charAt(j) - &#x27;a&#x27;));            &#125;            //(1.2)将bitWord放入bitWords数组中            bitWords[i] = bitWord;        &#125;        int res = 0;        //(2)暴力循环：当i与j对应的word进行&quot;与运算&quot;时，如果结果==0，则说明不存在相同字母        for (int i = 0; i &lt; n; i++) &#123;            for (int j = i; j &lt; n; j++) &#123;                //(2.1)不存在相同字母才进行计算                if ((bitWords[i]&amp;bitWords[j])==0) &#123;                    //(2.2)保存最大值                    res = Math.max(res, words[i].length() * words[j].length());                &#125;            &#125;        &#125;        return res;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<p><strong>解析：</strong></p>\n<p>官方解析链接：</p>\n<p><a href=\"https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode-solution-0t1i/\">比特位计数 - 比特位计数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p>来源链接：<a href=\"https://leetcode-cn.com/problems/counting-bits/solution/hen-qing-xi-de-si-lu-by-duadua/\">清晰的思路 - 比特位计数 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> n) &#123;        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n+<span class=\"number\">1</span>];        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>;i &lt;= n ;i++)&#123;            res[i] = res[i&amp;(i-<span class=\"number\">1</span>)] + <span class=\"number\">1</span>;        &#125;        <span class=\"keyword\">return</span> res;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>思路</strong></p>\n<p>对于所有的数字，只有两类：</p>\n<ol>\n<li>奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。</li>\n</ol>\n<ul>\n<li>```<pre><code>举例：    0 = 0       1 = 1   2 = 10      3 = 11\n</code></pre>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">1. 偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。</span><br><span class=\"line\"></span><br><span class=\"line\">- ```</span><br><span class=\"line\">      举例：   2 = 10       4 = 100       8 = 1000   3 = 11       6 = 110       12 = 1100</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] countBits(<span class=\"keyword\">int</span> num) &#123;      <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[num + <span class=\"number\">1</span>];      <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= num; i++)&#123;        <span class=\"keyword\">if</span> ((i &amp; <span class=\"number\">1</span>) == <span class=\"number\">0</span>)&#123; <span class=\"comment\">//奇数          result[i] = result[i &gt;&gt; 1];        &#125;else &#123;          result[i] = result[i - 1] + 1;        &#125;      &#125;      return result;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"1.链表","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E9%93%BE%E8%A1%A8/","content":"<h4 id=\"160-相交链表\"><a href=\"#160-相交链表\" class=\"headerlink\" title=\"160. 相交链表\"></a><a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">160. 相交链表</a></h4><p>难度：简单</p>\n<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>\n<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>\n<p><a href=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\"><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png\" alt=\"img\"></a></p>\n<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>\n<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>\n<p><strong>示例 1：</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png\"><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class=\"line\">输出：Intersected at &#x27;8&#x27;</span><br><span class=\"line\">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class=\"line\">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class=\"line\">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png\"><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class=\"line\">输出：Intersected at &#x27;2&#x27;</span><br><span class=\"line\">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class=\"line\">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class=\"line\">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<p><a href=\"https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png\"><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png\" alt=\"img\"></a></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class=\"line\">输出：null</span><br><span class=\"line\">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class=\"line\">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class=\"line\">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>listA</code> 中节点数目为 <code>m</code></li>\n<li><code>listB</code> 中节点数目为 <code>n</code></li>\n<li><code>0 &lt;= m, n &lt;= 3 * 104</code></li>\n<li><code>1 &lt;= Node.val &lt;= 105</code></li>\n<li><code>0 &lt;= skipA &lt;= m</code></li>\n<li><code>0 &lt;= skipB &lt;= n</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>\n<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>\n</ul>\n<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>\n<p><strong>解析：</strong></p>\n<p>空间复杂度 <em>O</em>(1) 时间复杂度为 <em>O</em>(<em>n</em>)</p>\n<p>这里使用图解的方式，解释比较巧妙的一种实现。</p>\n<p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p>\n<p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p>\n<ol>\n<li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li>\n<li>如果 pA 到了末尾，则 pA = headB 继续遍历</li>\n<li>如果 pB 到了末尾，则 pB = headA 继续遍历</li>\n<li>比较长的链表指针指向较短链表head时，长度差就消除了</li>\n<li>如此，只需要将最短链表遍历两次即可找到位置</li>\n</ol>\n<p>听着可能有点绕，看图最直观，链表的题目最适合看图了</p>\n<p><img src=\"https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png\" alt=\"相交链表.png\"></p>\n<p>代码也很简单（此处代码是参考评论区的高手的）</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (headA == <span class=\"keyword\">null</span> || headB == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\"><span class=\"comment\">//若相交，链表A： a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b = b+a 。</span></span><br><span class=\"line\"><span class=\"comment\">//题解：设链表A的长度为a+c，链表B的长度为b+c，a为链表A不公共部分，b为链表B不公共部分，c为链表A、B的公共部分,将两个链表连起来，A-&gt;B和B-&gt;A，长度：a+c+b+c=b+c+a+c，若链表AB相交，则a+c+b与b+c+a就会抵消，它们就会在c处相遇；若不相交，则c为nullptr，则a+b=b+a，它们各自移动到尾部循环结束，即返回nullptr</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    ListNode pA = headA, pB = headB;</span><br><span class=\"line\"><span class=\"comment\">//当pA或pB为空时，它们开始指向另一链表的头部，每次判断pA或pB是否为空进行赋值的好处是当链表AB没有公共部分时pA和pB同时为空，这样避免了死循环  (也即遍历两遍)</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (pA != pB) &#123;</span><br><span class=\"line\">        pA = pA == <span class=\"keyword\">null</span> ? headB : pA.next;</span><br><span class=\"line\">        pB = pB == <span class=\"keyword\">null</span> ? headA : pB.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pA;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度O(m+n)，其中 m 和 n 是分别是链表 headA 和headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>\n<p>空间复杂度：O(1)。</p>\n<h4 id=\"206-反转链表\"><a href=\"#206-反转链表\" class=\"headerlink\" title=\"206. 反转链表\"></a><a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">206. 反转链表</a></h4><p>难度：简单</p>\n<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5]</span><br><span class=\"line\">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2]</span><br><span class=\"line\">输出：[2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>\n<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>\n</ul>\n<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>\n<p><strong>解析：</strong>原作者链接：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/\">动画演示+多种解法 206. 反转链表 - 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><strong>利用外部空间</strong></p>\n<p>这种方式很简单，先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。<br>然后不断遍历链表，将链表中的元素添加到这个容器中。<br>再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。<br>最后同时遍历容器和链表，将链表中的值改为容器中的值。<br>因为此时容器的值是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">5 4 3 2 1</span><br></pre></td></tr></table></figure>\n\n<p>链表按这个顺序重新被设置一边，就达到要求啦。<br>当然你可以可以再新创建 N 个节点，然后再返回，这样也可以达到目的。<br>这种方式很简单，但你在面试中这么做的话，面试官 100% 会追问是否有更优的方式，比如不用外部空间。所以我就不做代码和动画演示了，下面来看看如何用 <em>O</em>(1) 空间复杂度来实现这道题。</p>\n<p><strong>双指针迭代</strong></p>\n<p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。<br>动画演示如下：<br><img src=\"https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif\" alt=\"迭代.gif\"></p>\n<p>动画演示中其实省略了一个<code>tmp</code>变量，这个<code>tmp</code>变量会将<code>cur</code>的下一个节点保存起来，考虑到一张动画放太多变量会很混乱，所以我就没加了，具体详细执行过程，请点击下面的幻灯片查看。</p>\n<p><img src=\"https://pic.leetcode-cn.com/8f03740e93c8a0ecff54a57a25a710ab82574faf99b3efb8ddd2b6eea1d78d49-1.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/aebc5e3ef0a6b942473a7c61f4de22e268cbfbe549ff1a6ad5d3eef7c667f875-2.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/4c160db670c00f7467c1dae3b22ac117b84c0ba00690ca30708fabcdd5ff35b1-3.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/95da97748c8a006b5b827d13154bd2202bed5c2b9d779bea6467473d16fd7d66-4.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/bbc75893b050a8c482178029bd239bd75c75e6a58a4a16fb9270b13044e4ddf3-5.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/9eda023eab4ecc76af90211626f77b695a4874b451084f8e2545717347815006-6.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/1829f246e991d3e27aa3dce9b18ab88282a1bd34a5363969eb5730fe74cf8fbf-7.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/3380338ba4b563c37199b07058d35fde9f9600d3112ef0b074e5986c2f4510e1-8.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/db831df3a7db0fc405a4dc8293bfc92ba6bba6cb1719613a4e8ab7afdf2a53dd-9.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/db7d85400d03237909fc904d52b71cf721dee82af47686756400fdf4d1f07493-10.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/549d1ed958285f378aea9a0db3a603253c83aff5439a76c0b8c35f2e237b9f4b-12.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/9683a6f2e465086ca1a9bcdb6b4cce9cdcc86da3269e1009867368923c76363d-13.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/9ef5549e7ff4b4748e0ff295ee37d3e172e7b910b397aa8718110b4779a9f689-14.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/074dcf7c17ba256aedbf4ba10d101ce93ed5425a6a1aa6d296a79be7bd65fc30-15.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/f6d200f6b154e8b4e9cf86c26e90c0e71af048fd4dac2f9a35eb8c9dc93bfa15-16.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/3b5504463012d23800d78e50948d1623cf405e32072cd1c630c71636a318d002-17.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/8c474aaee63b49b4cf981637039f65a41d70979a79fec22257576cfbcfb8c4c6-18.JPG\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/5eaed6c73d6dec3c3dc7728fda178711ff1a6a558ddf8f2a1946adf22525a44c-19.JPG\" alt=\"img\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//申请节点，pre和 cur，pre指向null</span></span><br><span class=\"line\">\t\tListNode pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\tListNode cur = head;</span><br><span class=\"line\">\t\tListNode tmp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span>(cur!=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//记录当前节点的下一个节点</span></span><br><span class=\"line\">\t\t\ttmp = cur.next;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//然后将当前节点指向pre</span></span><br><span class=\"line\">\t\t\tcur.next = pre;</span><br><span class=\"line\">\t\t\t<span class=\"comment\">//pre和cur节点都前进一位</span></span><br><span class=\"line\">\t\t\tpre = cur;</span><br><span class=\"line\">\t\t\tcur = tmp;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>递归解法</strong></p>\n<p>这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。<br>递归的两个条件：</p>\n<ol>\n<li>终止条件是当前节点或者下一个节点==null</li>\n<li>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">head.next.next = head</span><br></pre></td></tr></table></figure>\n\n<p>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：<br><img src=\"https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif\" alt=\"递归.gif\"></p>\n<p><strong>幻灯片演示</strong></p>\n<p>感谢<a href=\"https://leetcode-cn.com/u/zhuuuu-2/\">@zhuuuu-2</a>的建议，递归的解法光看动画比较容易理解，但真到了代码层面理解起来可能会有些困难，我补充了下递归调用的详细执行过程。</p>\n<p>以<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>这个链表为例，整个递归调用的执行过程，对应到代码层面(用java做示范)是怎么执行的，以及递归的调用栈都列出来了，请点击下面的幻灯片查看吧。</p>\n<p><img src=\"https://pic.leetcode-cn.com/f89c9e095d414b8366dd7d490508ba9c99d6c93953b4429168af262169f18e83-%E5%B9%BB%E7%81%AF%E7%89%876.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/485dbe9ad44ab7b05e01c46a1bc1718187a01f8a9fe8331f497e7011f9508b57-%E5%B9%BB%E7%81%AF%E7%89%877.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/04550182527e6570d9d04f2eeae330848b83d3ff13b23ea4153410210586dc85-%E5%B9%BB%E7%81%AF%E7%89%878.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/950f6edfb553cbeec65ce3c9679dd8d3401fd1837ad9eb16989217bf83f30e58-%E5%B9%BB%E7%81%AF%E7%89%8710.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/dcd5bef9b8ff3de98e9533da7da3a8411643bbef9bc5e1a576085b4403197649-%E5%B9%BB%E7%81%AF%E7%89%8711.jpg\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/1d6aaab3d9a42c20420fb6087e520ea05bd6d0789213f228481e55891b847b1e-%E5%B9%BB%E7%81%AF%E7%89%8712.jpg\" alt=\"img\"></p>\n<p>代码实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//解释</span><br><span class=\"line\">reverseList: head=1</span><br><span class=\"line\">    reverseList: head=2</span><br><span class=\"line\">\t    reverseList: head=3</span><br><span class=\"line\">\t\t    reverseList:head=4</span><br><span class=\"line\">\t\t\t    reverseList:head=5 </span><br><span class=\"line\">\t\t\t\t\t终止返回</span><br><span class=\"line\">\t\t\t\tcur = 5</span><br><span class=\"line\">\t\t\t\t4.next.next-&gt;4，即5-&gt;4</span><br><span class=\"line\">\t\t\tcur=5</span><br><span class=\"line\">\t\t\t3.next.next-&gt;3，即4-&gt;3</span><br><span class=\"line\">\t\tcur = 5</span><br><span class=\"line\">\t\t2.next.next-&gt;2，即3-&gt;2</span><br><span class=\"line\">\tcur = 5</span><br><span class=\"line\">\t1.next.next-&gt;1，即2-&gt;1</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t最后返回cur</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"comment\">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(head==<span class=\"keyword\">null</span> || head.next==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> head;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里的cur就是最后一个节点</span></span><br><span class=\"line\">\t\tListNode cur = reverseList(head.next);</span><br><span class=\"line\">\t\t<span class=\"comment\">//这里请配合动画演示理解</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//而head是4，head的下一个是5，下下一个是空</span></span><br><span class=\"line\">\t\t<span class=\"comment\">//所以head.next.next 就是5-&gt;4</span></span><br><span class=\"line\">\t\thead.next.next = head;</span><br><span class=\"line\">\t\t<span class=\"comment\">//防止链表循环，需要将head.next设置为空</span></span><br><span class=\"line\">\t\thead.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t\t<span class=\"comment\">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> cur;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"21-合并两个有序链表\"><a href=\"#21-合并两个有序链表\" class=\"headerlink\" title=\"21. 合并两个有序链表\"></a><a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">21. 合并两个有序链表</a></h4><p>难度：简单</p>\n<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class=\"line\">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [], l2 = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [], l2 = [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>\n</ul>\n<p><strong>解析：</strong>解题链接：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/\">合并两个有序链表 - 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>\n<p><strong>递归：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">解释：<span class=\"comment\">//(1,1):代表第一次进入递归函数，并且从第一个口进入，并且记录进入前链表的状态</span></span><br><span class=\"line\">merge(<span class=\"number\">1</span>,<span class=\"number\">1</span>): <span class=\"number\">1</span>-&gt;<span class=\"number\">4</span>-&gt;<span class=\"number\">5</span>-&gt;<span class=\"keyword\">null</span>, <span class=\"number\">1</span>-&gt;<span class=\"number\">2</span>-&gt;<span class=\"number\">3</span>-&gt;<span class=\"number\">6</span>-&gt;<span class=\"function\"><span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">2</span>,<span class=\"number\">2</span>)</span>: 4-&gt;5-&gt;<span class=\"keyword\">null</span>, 1-&gt;2-&gt;3-&gt;6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t<span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">2</span>)</span>: 4-&gt;5-&gt;<span class=\"keyword\">null</span>, 2-&gt;3-&gt;6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t\t<span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">4</span>,<span class=\"number\">2</span>)</span>: 4-&gt;5-&gt;<span class=\"keyword\">null</span>, 3-&gt;6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t\t\t<span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">5</span>,<span class=\"number\">1</span>)</span>: 4-&gt;5-&gt;<span class=\"keyword\">null</span>, 6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t\t\t\t<span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">6</span>,<span class=\"number\">1</span>)</span>: 5-&gt;<span class=\"keyword\">null</span>, 6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t\t\t\t\t<span class=\"title\">merge</span><span class=\"params\">(<span class=\"number\">7</span>)</span>: <span class=\"keyword\">null</span>, 6-&gt;<span class=\"keyword\">null</span></span></span><br><span class=\"line\"><span class=\"function\">    \t\t\t\t\treturn l2</span></span><br><span class=\"line\"><span class=\"function\">    \t\t\t\tl1.next --- 5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l1</span></span><br><span class=\"line\"><span class=\"function\">    \t\t\tl1.next --- 4-&gt;5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l1</span></span><br><span class=\"line\"><span class=\"function\">    \t\tl2.next --- 3-&gt;4-&gt;5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l2</span></span><br><span class=\"line\"><span class=\"function\">    \tl2.next --- 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l2</span></span><br><span class=\"line\"><span class=\"function\">    l2.next --- 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l2</span></span><br><span class=\"line\"><span class=\"function\">l1.next --- 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;<span class=\"keyword\">null</span>, return l1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (l1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class=\"line\">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> l2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即O(n+m)。</p>\n</li>\n<li><p>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为O(n+m)。</p>\n</li>\n</ul>\n<p><strong>迭代：</strong></p>\n<p><img src=\"https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.sinaimg.cn%2Fmw690%2F006Tiah4zy7dwacE4z751%26690&refer=http%3A%2F%2Fs2.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629272494&t=3887a34bb0f2562d0a5ed0bc53bdab64\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">mergeTwoLists</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        ListNode prehead = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>)<span class=\"comment\">//新建哑节点（伪头节点），值为-1，哑节点不是头节点，是新造的一个伪头节点，但是它存储的地址和头节点一样</span></span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode prev = prehead;<span class=\"comment\">//之所以赋值给prev  这里prev可以当作游标往后移动，否则最后返回prev就不对</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"keyword\">null</span> &amp;&amp; l2 != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class=\"line\">                prev.next = l1;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                prev.next = l2;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            prev = prev.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span></span><br><span class=\"line\">        prev.next = l1 == <span class=\"keyword\">null</span> ? l2 : l1;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> prehead.next;<span class=\"comment\">//下一节点地址。相当于头节点 </span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p>\n<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>\n<h4 id=\"83-删除排序链表中的重复元素\"><a href=\"#83-删除排序链表中的重复元素\" class=\"headerlink\" title=\"83. 删除排序链表中的重复元素\"></a><a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\">83. 删除排序链表中的重复元素</a></h4><p>难度简单608</p>\n<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>\n<p>返回同样按升序排列的结果链表。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/list1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/04/list2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,1,2,3,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n<li>题目数据保证链表已经按升序排列</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>递归</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> || head.next==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        head.next = deleteDuplicates(head.next);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>  head.val == head.next.val ? head.next:head;       </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/users/guanpengchn/avatar_1580451118.png?x-oss-process=image/resize,h_38,w_38/format,webp\" alt=\"img\"></p>\n<p><strong>思路</strong></p>\n<ul>\n<li>标签：链表</li>\n<li>指定 cur 指针指向头部 head</li>\n<li>当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了</li>\n<li>当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果</li>\n<li>如果不相等则 cur 移动到下一个位置继续循环</li>\n<li>时间复杂度：<em>O</em>(<em>n</em>)</li>\n</ul>\n<p><strong>代码</strong></p>\n<ul>\n<li><strong>迭代</strong></li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * Definition for singly-linked list.</span><br><span class=\"line\"> * public class ListNode &#123;</span><br><span class=\"line\"> *     int val;</span><br><span class=\"line\"> *     ListNode next;</span><br><span class=\"line\"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class=\"line\"> * &#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode deleteDuplicates(ListNode head) &#123;        </span><br><span class=\"line\">        ListNode cur = head;</span><br><span class=\"line\">        while(cur != null &amp;&amp; cur.next != null) &#123;//因为测试的时候的链表可能给的[] 所以cur!=null的判定也要给上~</span><br><span class=\"line\">            if(cur.val == cur.next.val) &#123;</span><br><span class=\"line\">                //因为是升序排列 所以也只可能是挨着的二位相同辽~</span><br><span class=\"line\">                cur.next = cur.next.next;//删除重复的辣个cur.next</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else &#123;</span><br><span class=\"line\">                cur = cur.next;//cur继续前移</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return head;//返回结果链表</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>画解</strong></p>\n<p><img src=\"https://pic.leetcode-cn.com/c61a88b9fe012a9b85b842f4a12a5310c96b462ea4801e6227fc6a04aa140351-frame_00001.png\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/87a5f06f4a257e5970af228ea0c37b1b1513d5b53770da8d409616a5fd9afaa5-frame_00002.png\" alt=\"img\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/b8f2dae3ca21a552bff2e2486f2f838f78aaa505066113c4453900ae182edbd3-frame_00003.png\" alt=\"img\"></p>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的长度。</li>\n<li>空间复杂度：<em>O</em>(1)。</li>\n</ul>\n<h4 id=\"19-删除链表的倒数第-N-个结点\"><a href=\"#19-删除链表的倒数第-N-个结点\" class=\"headerlink\" title=\"19. 删除链表的倒数第 N 个结点\"></a><a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">19. 删除链表的倒数第 N 个结点</a></h4><p>难度：中等</p>\n<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>\n<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4,5], n = 2</span><br><span class=\"line\">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1], n = 1</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2], n = 1</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中结点的数目为 <code>sz</code></li>\n<li><code>1 &lt;= sz &lt;= 30</code></li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n<li><code>1 &lt;= n &lt;= sz</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><img src=\"C:\\Users\\Wanan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210719165432927.png\" alt=\"image-20210719165432927\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/19/p3.png\" alt=\"p3\"></p>\n<p><strong>官方代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode dummy = <span class=\"keyword\">new</span> ListNode(<span class=\"number\">0</span>, head);</span><br><span class=\"line\">        ListNode first = head;</span><br><span class=\"line\">        ListNode second = dummy;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (first != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            first = first.next;</span><br><span class=\"line\">            second = second.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        second.next = second.next.next;</span><br><span class=\"line\">        ListNode ans = dummy.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 start.next != <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>自己代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode head, <span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n-- &gt;<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(fast == <span class=\"keyword\">null</span>)  <span class=\"keyword\">return</span> head.next;<span class=\"comment\">//如果fast == null  说明fast经过以为遍历到了最后一个节点的后一位，此时n = 链表长度，说明要删除的是第一个节点。</span></span><br><span class=\"line\">        ListNode slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast.next != <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">//因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 fast.next != null</span></span><br><span class=\"line\">            fast = fast.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        slow.next = slow.next.next;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>L</em>)，其中 <em>L</em> 是链表的长度。</li>\n<li>空间复杂度：<em>O</em>(1)。</li>\n</ul>\n<h4 id=\"24-两两交换链表中的节点\"><a href=\"#24-两两交换链表中的节点\" class=\"headerlink\" title=\"24. 两两交换链表中的节点\"></a><a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">24. 两两交换链表中的节点</a></h4><p>难度：中等</p>\n<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>\n<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1,2,3,4]</span><br><span class=\"line\">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：head = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p>\n<p><strong>解析：</strong></p>\n<p><strong>方法二：迭代</strong></p>\n<p><strong>思路与算法</strong></p>\n<p>也可以通过迭代的方式实现两两交换链表中的节点。</p>\n<p>创建哑结点 <code>dummyHead</code>，令 <code>dummyHead.next = head</code>。令 <code>temp</code> 表示当前到达的节点，初始时 <code>temp = dummyHead</code>。每次需要交换 <code>temp</code> 后面的两个节点。</p>\n<p>如果 <code>temp</code> 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 <code>temp</code> 后面的两个节点 <code>node1</code> 和 <code>node2</code>，通过更新节点的指针关系实现两两交换节点。</p>\n<p>具体而言，交换之前的节点关系是 <code>temp -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>temp -&gt; node2 -&gt; node1</code>，因此需要进行如下操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">temp.next = node2</span><br><span class=\"line\">node1.next = node2.next</span><br><span class=\"line\">node2.next = node1</span><br></pre></td></tr></table></figure>\n\n<p>完成上述操作之后，节点关系即变成 <code>temp -&gt; node2 -&gt; node1</code>。再令 <code>temp = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>\n<p>两两交换链表中的节点之后，新的链表的头节点是 <code>dummyHead.next</code>，返回新的链表的头节点即可。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/24/6.png\" alt=\"img\"></p>\n<p>6 / 13</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public ListNode swapPairs(ListNode head) &#123;</span><br><span class=\"line\">        ListNode dummyHead = new ListNode(0);//创建一个头节点</span><br><span class=\"line\">        dummyHead.next = head;</span><br><span class=\"line\">        ListNode temp = dummyHead;</span><br><span class=\"line\">        while (temp.next != null &amp;&amp; temp.next.next != null) &#123;</span><br><span class=\"line\">            ListNode node1 = temp.next;</span><br><span class=\"line\">            ListNode node2 = temp.next.next;</span><br><span class=\"line\">            temp.next = node2;</span><br><span class=\"line\">            node1.next = node2.next;</span><br><span class=\"line\">            node2.next = node1;</span><br><span class=\"line\">            temp = node1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return dummyHead.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的节点数量。需要对每个节点进行更新指针的操作。</li>\n<li>空间复杂度：<em>O</em>(1)。</li>\n</ul>\n<h4 id=\"445-两数相加-II\"><a href=\"#445-两数相加-II\" class=\"headerlink\" title=\"445. 两数相加 II\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers-ii/\">445. 两数相加 II</a></h4><p>难度：中等</p>\n<p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>\n<p><strong>示例1：</strong></p>\n<p><img src=\"https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [7,2,4,3], l2 = [5,6,4]</span><br><span class=\"line\">输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class=\"line\">输出：[8,0,7]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：l1 = [0], l2 = [0]</span><br><span class=\"line\">输出：[0]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>链表的长度范围为<code> [1, 100]</code></li>\n<li><code>0 &lt;= node.val &lt;= 9</code></li>\n<li>输入数据保证链表代表的数字无前导 0</li>\n</ul>\n<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>\n<p><strong>解析：</strong></p>\n<p>这道题可以通过使用栈来解决，我们需要构建两个栈，将两个链表中的值分别压入这两个栈中。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1612843418-hDCiPe-image.png\" alt=\"image.png\"></p>\n<p>每次都从两个栈中各弹出一个元素，就是我们所需要的最末位元素，按照计算方式，相加取模求当前位的值，同时我们还需要记录当前位的进位。最后，我们使用获得的值，构建一个节点。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1612843430-WwISBz-image.png\" alt=\"image.png\"></p>\n<p>我们需要使用一个指针作为头指针，指向当前节点。每次新增节点，我们只需要将新节点插入到头指针之后即可。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1612843449-czpjTW-image.png\" alt=\"image.png\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack1  =  <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        Deque&lt;Integer&gt; stack2  =  <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l1 != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            stack1.push(l1.val);</span><br><span class=\"line\">            l1 = l1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(l2 != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            stack2.push(l2.val);</span><br><span class=\"line\">            l2 = l2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ListNode head = <span class=\"keyword\">new</span> ListNode(-<span class=\"number\">1</span>);<span class=\"comment\">//创建一个头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> carry =<span class=\"number\">0</span>;<span class=\"comment\">//存储进位</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack1.isEmpty() || !stack2.isEmpty() || carry!=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> x = stack1.isEmpty() ? <span class=\"number\">0</span>:stack1.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> y = stack2.isEmpty() ? <span class=\"number\">0</span>:stack2.pop();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum  = x + y + carry;</span><br><span class=\"line\">            carry = sum /<span class=\"number\">10</span>;</span><br><span class=\"line\">            ListNode tmp =<span class=\"keyword\">new</span> ListNode(sum %<span class=\"number\">10</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">            tmp.next = head.next;<span class=\"comment\">//把当前节点的下一节点指向头节点的下一个节点          </span></span><br><span class=\"line\">            head.next = tmp;<span class=\"comment\">//再把当前节点 变为头节点下一节点   </span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过栈的形式：实现两个链表相加</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//创建两个栈：存放两个链表的value</span></span><br><span class=\"line\">       Stack&lt;Integer&gt; stack1 = <span class=\"keyword\">new</span> Stack&lt;&gt;();      <span class=\"comment\">//存放l1的value</span></span><br><span class=\"line\">       Stack&lt;Integer&gt; stack2 = <span class=\"keyword\">new</span> Stack&lt;&gt;();      <span class=\"comment\">//存放l2的value</span></span><br><span class=\"line\">       <span class=\"comment\">//创建一个：指向null的结点</span></span><br><span class=\"line\">       ListNode head = <span class=\"keyword\">null</span>;           </span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将l1的value放入：stack1</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span>(l1 != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           stack1.push(l1.val);</span><br><span class=\"line\">           l1 = l1.next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//将l2的value放入：stack2</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span>(l2 != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">           stack2.push(l2.val);</span><br><span class=\"line\">           l2 = l2.next;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//自定义：循环变量</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> carry = <span class=\"number\">0</span>;               <span class=\"comment\">//记录：来自低位的进位</span></span><br><span class=\"line\">       <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;                 <span class=\"comment\">//记录两个链表相加的：value值</span></span><br><span class=\"line\">       ListNode newNode = <span class=\"keyword\">null</span>;    <span class=\"comment\">//用于记录：新链表，创建的结点</span></span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//循环判断</span></span><br><span class=\"line\">       <span class=\"keyword\">while</span>(!stack1.empty() || !stack2.empty() || carry &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">           <span class=\"comment\">//循环体</span></span><br><span class=\"line\">           num = carry;           <span class=\"comment\">//记录来自：低位的进位， 如果没有，则为0，否则为1</span></span><br><span class=\"line\">           num += stack1.empty() ? <span class=\"number\">0</span>:stack1.pop();     <span class=\"comment\">//加上l1的栈顶value</span></span><br><span class=\"line\">           num += stack2.empty() ? <span class=\"number\">0</span>:stack2.pop();     <span class=\"comment\">//加上l2的栈顶value</span></span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//改变变量</span></span><br><span class=\"line\">           newNode = <span class=\"keyword\">new</span> ListNode(num%<span class=\"number\">10</span>);</span><br><span class=\"line\">           <span class=\"comment\">//利用头插法：插入到新链表</span></span><br><span class=\"line\">           newNode.next = head;                        <span class=\"comment\">//指向第一个有效结点</span></span><br><span class=\"line\">           head = newNode;                             <span class=\"comment\">//第一个有效结点：向前移动</span></span><br><span class=\"line\">           carry = num/<span class=\"number\">10</span>;                              <span class=\"comment\">//记录：进位</span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"234-回文链表\"><a href=\"#234-回文链表\" class=\"headerlink\" title=\"234. 回文链表\"></a><a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">234. 回文链表</a></h4><p>难度：简单</p>\n<p>请判断一个链表是否为回文链表。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 1-&gt;2</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>\n<p><strong>方法三：快慢指针</strong><br><strong>思路</strong></p>\n<p>避免使用 O(n) 额外空间的方法就是改变输入。</p>\n<p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p>\n<p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p>\n<p><strong>算法</strong></p>\n<p>整个流程可以分为以下五个步骤：</p>\n<ol>\n<li>找到前半部分链表的尾节点。</li>\n<li>反转后半部分链表。</li>\n<li>判断是否回文。</li>\n<li>恢复链表。</li>\n<li>返回结果。</li>\n</ol>\n<p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p>\n<p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p>\n<p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>\n<p>步骤二可以使用「206. 反转链表」问题中的解决方法来反转链表的后半部分。</p>\n<p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>\n<p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isPalindrome</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找到前半部分链表的尾节点并反转后半部分链表</span></span><br><span class=\"line\">        ListNode firstHalfEnd = endOfFirstHalf(head);</span><br><span class=\"line\">        ListNode secondHalfStart = reverseList(firstHalfEnd.next);</span><br><span class=\"line\">       </span><br><span class=\"line\">       <span class=\"comment\">//判断是否回文</span></span><br><span class=\"line\">        ListNode p1 = head;</span><br><span class=\"line\">        ListNode p2 = secondHalfStart;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(result &amp;&amp; p2 != <span class=\"keyword\">null</span>)&#123; <span class=\"comment\">//因为链表奇数点时，奇数点属于前一链表，所以后半部分总比前半部分少, 所以判断p2是否等于null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p1.val != p2.val)&#123;</span><br><span class=\"line\">            result =<span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        p1 = p1.next;</span><br><span class=\"line\">        p2 = p2.next;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//还原链表并返回结果</span></span><br><span class=\"line\">        firstHalfEnd.next = reverseList(secondHalfStart);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">endOfFirstHalf</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        ListNode fast =head,slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast.next != <span class=\"keyword\">null</span> &amp;&amp; fast.next.next != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slow;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span>  ListNode <span class=\"title\">reverseList</span><span class=\"params\">(ListNode head)</span></span>&#123;</span><br><span class=\"line\">        ListNode newHead = <span class=\"keyword\">null</span>;<span class=\"comment\">//新建的一个头节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            ListNode temNode = head.next;</span><br><span class=\"line\">            head.next = newHead;</span><br><span class=\"line\">            newHead = head;</span><br><span class=\"line\">            head = temNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newHead;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<p>时间复杂度：O(n)，其中 n 指的是链表的大小。</p>\n<p>空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</p>\n<h4 id=\"725-分隔链表\"><a href=\"#725-分隔链表\" class=\"headerlink\" title=\"725. 分隔链表\"></a><a href=\"https://leetcode-cn.com/problems/split-linked-list-in-parts/\">725. 分隔链表</a></h4><p>难度：中等</p>\n<p>给定一个头结点为 <code>root</code> 的链表, 编写一个函数以将链表分隔为 <code>k</code> 个连续的部分。</p>\n<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>\n<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>\n<p>返回一个符合上述规则的链表的列表。</p>\n<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">root = [1, 2, 3], k = 5</span><br><span class=\"line\">输出: [[1],[2],[3],[],[]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">输入输出各部分都应该是链表，而不是数组。</span><br><span class=\"line\">例如, 输入的结点 root 的 val= 1, root.next.val = 2, \\root.next.next.val = 3, 且 root.next.next.next = null。</span><br><span class=\"line\">第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。</span><br><span class=\"line\">最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: </span><br><span class=\"line\">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</span><br><span class=\"line\">输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</span><br><span class=\"line\">解释:</span><br><span class=\"line\">输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li><code>root</code> 的长度范围： <code>[0, 1000]</code>.</li>\n<li>输入的每个节点的大小范围：<code>[0, 999]</code>.</li>\n<li><code>k</code> 的取值范围： <code>[1, 50]</code>.</li>\n</ul>\n<p> <strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode[] splitListToParts(ListNode head, <span class=\"keyword\">int</span> k) &#123;<span class=\"comment\">//这里的head直接指向第一个有效节点的地址。与c++不一样</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = <span class=\"number\">0</span>;</span><br><span class=\"line\">        ListNode cur = head;<span class=\"comment\">//避免以后找不到head</span></span><br><span class=\"line\">        <span class=\"comment\">//遍历链表长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            N++;</span><br><span class=\"line\">            cur = cur.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> size = N/k;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mod = N%k;</span><br><span class=\"line\">        ListNode[] res = <span class=\"keyword\">new</span> ListNode[k];</span><br><span class=\"line\">        cur = head;<span class=\"comment\">//重置cur 为head起点</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>;cur!=<span class=\"keyword\">null</span>&amp;&amp;i&lt;k;i++)&#123;<span class=\"comment\">//这里外循环是遍历k段链表</span></span><br><span class=\"line\">            res[i] = cur;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> curSize = size + (mod-- &gt;<span class=\"number\">0</span> ? <span class=\"number\">1</span>:<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j =<span class=\"number\">0</span>;j&lt;curSize-<span class=\"number\">1</span>;j++)&#123;<span class=\"comment\">// 假如18个数，分为5段，那么就是4，4，4，3，3. 这里curSize = 4</span></span><br><span class=\"line\">              <span class=\"comment\">//curSize-1 =3    那么从1开始遍历三次 也就是0，1，2即可。1-&gt;2-&gt;3-&gt;4有三个指针</span></span><br><span class=\"line\">                cur = cur.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//断开每部分链表</span></span><br><span class=\"line\">            ListNode next =cur.next;</span><br><span class=\"line\">            cur.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            cur = next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(N+k)。N 指的是所给链表的结点数，若 k 很大，则还需要添加许多空列表。</li>\n<li>空间复杂度：O(k)，存储答案时所需的额外空格。</li>\n</ul>\n<h4 id=\"328-奇偶链表\"><a href=\"#328-奇偶链表\" class=\"headerlink\" title=\"328. 奇偶链表\"></a><a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\">328. 奇偶链表</a></h4><p>难度：中等</p>\n<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>\n<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class=\"line\">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class=\"line\">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明:</strong></p>\n<ul>\n<li>应当保持奇数节点和偶数节点的相对顺序。</li>\n<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/328/1.png\" alt=\"fig1\"></p>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)，其中 n 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p>\n</li>\n<li><p>空间复杂度：O(1)。只需要维护有限的指针。</p>\n</li>\n</ul>\n","categories":["leetcode","数据结构"],"tags":["数据结构"]},{"title":"2.树","url":"/2021/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E6%A0%91/","content":"<h4 id=\"104-二叉树的最大深度\"><a href=\"#104-二叉树的最大深度\" class=\"headerlink\" title=\"104. 二叉树的最大深度\"></a><a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">104. 二叉树的最大深度</a></h4><p>难度：简单</p>\n<p>给定一个二叉树，找出其最大深度。</p>\n<p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>\n<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>\n<p><strong>示例：</strong><br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  3</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">9  20</span><br><span class=\"line\">  /  \\</span><br><span class=\"line\"> 15   7</span><br></pre></td></tr></table></figure>\n\n<p>返回它的最大深度 3 。</p>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(maxDepth(root.left),maxDepth(root.right)) +<span class=\"number\">1</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"110-平衡二叉树\"><a href=\"#110-平衡二叉树\" class=\"headerlink\" title=\"110. 平衡二叉树\"></a><a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">110. 平衡二叉树</a></h4><p>难度:简单</p>\n<p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p>\n<p>本题中，一棵高度平衡二叉树定义为：</p>\n<blockquote>\n<p>一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1 。</p>\n</blockquote>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,9,20,null,null,15,7]</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/06/balance_2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,2,3,3,null,null,4,4]</span><br><span class=\"line\">输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> result = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        maxDepth(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = maxDepth(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = maxDepth(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(Math.abs(left- right) &gt;<span class=\"number\">1</span>) result = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(left,right) +<span class=\"number\">1</span>; </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>方法一：自顶向下的递归</strong></p>\n<p>定义函数 height，用于计算二叉树中的任意一个节点 <em>p</em> 的高度：</p>\n<p><img src=\"C:\\Users\\Wanan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210712194752699.png\" alt=\"image-20210712194752699\"></p>\n<p>有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/110/1_1.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class=\"line\">        if (root == null) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return Math.abs(height(root.left) - height(root.right)) &lt;= 1 &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int height(TreeNode root) &#123;</span><br><span class=\"line\">        if (root == null) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            return Math.max(height(root.left), height(root.right)) + 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n^2)，其中 <em>n</em> 是二叉树中的节点个数。<br>最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 <em>O</em>(<em>n</em>)。<br>对于节点 p<em>，如果它的高度是 d</em>，则 height(<em>p</em>) 最多会被调用 <em>d</em> 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 <em>h</em> 满足O*(<em>h</em>)=<em>O</em>(log<em>n</em>)，因为 <em>d</em>≤<em>h</em>，所以总时间复杂度为 O*(<em>n</em>log*n)。对于最坏的情况，二叉树形成链式结构，高度为 <em>O</em>(<em>n</em>)，此时总时间复杂度为 O(n^2)。</li>\n<li>空间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 <em>n</em>。</li>\n</ul>\n<p><strong>方法二：自底向上的递归</strong></p>\n<p>方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。</p>\n<p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 −1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/110/2_1.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> height(root) &gt;= <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">height</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftHeight = height(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightHeight = height(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (leftHeight == -<span class=\"number\">1</span> || rightHeight == -<span class=\"number\">1</span> || Math.abs(leftHeight - rightHeight) &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.max(leftHeight, rightHeight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 <em>O</em>(<em>n</em>)。</li>\n<li>空间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 <em>n</em>。</li>\n</ul>\n<p><strong>改进方法</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">官方解还可以进一步优化，如果左子树已经返回-<span class=\"number\">1</span>了就不需要再递归右子树了，直接返回-<span class=\"number\">1</span>就可以了，代码如下。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isBalanced</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> balanced(root) != -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">balanced</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftHeight, rightHeight;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((leftHeight = balanced(node.left)) == -<span class=\"number\">1</span></span><br><span class=\"line\">                || (rightHeight = balanced(node.right)) == -<span class=\"number\">1</span></span><br><span class=\"line\">                || Math.abs(leftHeight - rightHeight) &gt; <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(leftHeight, rightHeight) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"543-二叉树的直径\"><a href=\"#543-二叉树的直径\" class=\"headerlink\" title=\"543. 二叉树的直径\"></a><a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\">543. 二叉树的直径</a></h4><p>难度：简单</p>\n<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>\n<p><strong>示例 :</strong><br>给定二叉树</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   3</span><br><span class=\"line\"> / \\     </span><br><span class=\"line\">4   5    </span><br></pre></td></tr></table></figure>\n\n<p>返回 <strong>3</strong>, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p>\n<p><strong>注意：</strong>两结点之间的路径长度是以它们之间边的数目表示。</p>\n<p><strong>方法一：深度优先搜索</strong></p>\n<p>首先我们知道一条路径的长度为该路径经过的节点数减一，所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</p>\n<p>而任意一条路径均可以被看作由某个节点为起点，从其左儿子和右儿子向下遍历的路径拼接得到。</p>\n<p><img src=\"https://pic.leetcode-cn.com/f39419c0fd3b3225a643ac4f40a1289c93cb03a6fb07a0be9e763c732a49b47d-543.jpg\" alt=\"543.jpg\"></p>\n<p>如图我们可以知道路径 <code>[9, 4, 2, 5, 7, 8]</code> 可以被看作以 22 为起点，从其左儿子向下遍历的路径 <code>[2, 4, 9]</code> 和从其右儿子向下遍历的路径 <code>[2, 5, 7, 8]</code> 拼接得到。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> max =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">diameterOfBinaryTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        maxDepth(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> max;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">maxDepth</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = maxDepth(root.left);<span class=\"comment\">// 左儿子为根的子树的深度</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = maxDepth(root.right); <span class=\"comment\">// 右儿子为根的子树的深度</span></span><br><span class=\"line\">        max = Math.max(max,left + right);<span class=\"comment\">// 计算d_node即L+R+1 并更新ans</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(left,right) +<span class=\"number\">1</span>;<span class=\"comment\">// 返回该节点为根的子树的深度</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 为二叉树的节点数，即遍历一棵二叉树的时间复杂度，每个结点只被访问一次。</li>\n<li>空间复杂度：<em>O</em>(<em>H<strong>e</strong>i<strong>g</strong>h</em> <em>t</em>)，其中 <em>H<strong>e</strong>i<strong>g</strong>h</em> <em>t</em> 为二叉树的高度。由于递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，而递归的深度显然为二叉树的高度，并且每次递归调用的函数里又只用了常数个变量，所以所需空间复杂度为 <em>O</em>(<em>H<strong>e</strong>i<strong>g</strong>h</em>t) 。</li>\n</ul>\n<h4 id=\"226-翻转二叉树\"><a href=\"#226-翻转二叉树\" class=\"headerlink\" title=\"226. 翻转二叉树\"></a><a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">226. 翻转二叉树</a></h4><p>难度：简单</p>\n<p>翻转一棵二叉树。</p>\n<p><strong>示例：</strong></p>\n<p>输入：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  2     7</span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\">1   3 6   9</span><br></pre></td></tr></table></figure>\n\n<p>输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">     4</span><br><span class=\"line\">   /   \\</span><br><span class=\"line\">  7     2</span><br><span class=\"line\"> / \\   / \\</span><br><span class=\"line\">9   6 3   1</span><br></pre></td></tr></table></figure>\n\n<p><strong>备注:</strong><br>这个问题是受到 <a href=\"https://twitter.com/mxcl\">Max Howell </a>的 <a href=\"https://twitter.com/mxcl/status/608682016205344768\">原问题</a> 启发的 ：</p>\n<blockquote>\n<p>谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。</p>\n</blockquote>\n<p><strong>方法一：递归</strong></p>\n<p><strong>思路与算法</strong></p>\n<p>这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 <em>root</em> 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 *root* 为根节点的整棵子树的翻转。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">invertTree</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode left = invertTree(root.left);</span><br><span class=\"line\">        TreeNode right = invertTree(root.right);</span><br><span class=\"line\">        root.left = right;</span><br><span class=\"line\">        root.right = left;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。</li>\n<li>空间复杂度：<em>O</em>(<em>N</em>)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即<em>O</em>(log<em>N</em>)。而在最坏情况下，树形成链状，空间复杂度为 <em>O</em>(<em>N</em>)。</li>\n</ul>\n<p><strong>方法一：深度优先搜索</strong></p>\n<p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>\n<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>\n<ul>\n<li>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</li>\n<li>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</li>\n<li>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</li>\n</ul>\n<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/617/1.png\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">mergeTrees</span><span class=\"params\">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t1 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t2 == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> t1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        TreeNode merged = <span class=\"keyword\">new</span> TreeNode(t1.val + t2.val);</span><br><span class=\"line\">        merged.left = mergeTrees(t1.left, t2.left);</span><br><span class=\"line\">        merged.right = mergeTrees(t1.right, t2.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> merged;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(min(<em>m</em>,<em>n</em>))，其中 <em>m</em> 和 <em>n</em> 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。</li>\n<li>空间复杂度：<em>O</em>(min(<em>m</em>,<em>n</em>))，其中 <em>m</em> 和 <em>n</em> 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</li>\n</ul>\n<h4 id=\"112-路径总和\"><a href=\"#112-路径总和\" class=\"headerlink\" title=\"112. 路径总和\"></a><a href=\"https://leetcode-cn.com/problems/path-sum/\">112. 路径总和</a></h4><p>难度：简单</p>\n<p>给你二叉树的根节点 <code>root</code> 和一个表示目标和的整数 <code>targetSum</code> ，判断该树中是否存在 <strong>根节点到叶子节点</strong> 的路径，这条路径上所有节点值相加等于目标和 <code>targetSum</code> 。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22</span><br><span class=\"line\">输出：true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2,3], targetSum = 5输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], targetSum = 0输出：false</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数目在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n<p>注意到本题的要求是，询问是否有从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<blockquote>\n<p>需要特别注意的是，给定的 <code>root</code> 可能为空。</p>\n</blockquote>\n<p><strong>方法一：广度优先搜索</strong></p>\n<p><strong>思路及算法</strong></p>\n<p>首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。</p>\n<p>这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/112/1.png\" alt=\"img\"></p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queNode = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        Queue&lt;Integer&gt; queVal = <span class=\"keyword\">new</span> LinkedList&lt;Integer&gt;();</span><br><span class=\"line\">        queNode.offer(root);</span><br><span class=\"line\">        queVal.offer(root.val);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!queNode.isEmpty()) &#123;</span><br><span class=\"line\">            TreeNode now = queNode.poll();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = queVal.poll();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left == <span class=\"keyword\">null</span> &amp;&amp; now.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (temp == sum) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.left);</span><br><span class=\"line\">                queVal.offer(now.left.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (now.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                queNode.offer(now.right);</span><br><span class=\"line\">                queVal.offer(now.right.val + temp);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>\n</ul>\n<p><strong>方法二：递归</strong></p>\n<p><strong>思路及算法</strong></p>\n<p>观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 <code>root</code> 到叶子节点的路径，满足其路径和为 <code>sum</code>。</p>\n<p>假定从根节点到当前节点的值之和为 <code>val</code>，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 <code>sum - val</code>。</p>\n<p>不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 <code>sum</code> 是否等于 <code>val</code> 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> sum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> sum == root.val;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<em>O</em>(<em>H</em>)，其中 <em>H</em> 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 <em>O</em>(<em>N</em>)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 <em>O</em>(log<em>N</em>)。</li>\n</ul>\n<h4 id=\"437-路径总和-III\"><a href=\"#437-路径总和-III\" class=\"headerlink\" title=\"437. 路径总和 III\"></a><a href=\"https://leetcode-cn.com/problems/path-sum-iii/\">437. 路径总和 III</a></h4><p>难度：中等</p>\n<p>给定一个二叉树，它的每个结点都存放着一个整数值。</p>\n<p>找出路径和等于给定数值的路径总数。</p>\n<p>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>\n<p>二叉树不超过1000个节点，且节点数值范围是 [-1000000,1000000] 的整数。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class=\"line\"></span><br><span class=\"line\">      10</span><br><span class=\"line\">     /  \\</span><br><span class=\"line\">    5   -3</span><br><span class=\"line\">   / \\    \\</span><br><span class=\"line\">  3   2   11</span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\">3  -2   1</span><br><span class=\"line\"></span><br><span class=\"line\">返回 3。和等于 8 的路径有:</span><br><span class=\"line\"></span><br><span class=\"line\">1.  5 -&gt; 3</span><br><span class=\"line\">2.  5 -&gt; 2 -&gt; 1</span><br><span class=\"line\">3.  -3 -&gt; 11</span><br></pre></td></tr></table></figure>\n\n<p><strong>简单做法</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> targetSum)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>)  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        dfs(root,targetSum);</span><br><span class=\"line\">        pathSum(root.left,targetSum);</span><br><span class=\"line\">        pathSum(root.right,targetSum);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root,<span class=\"keyword\">int</span> targetSum)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        targetSum -= root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(targetSum == <span class=\"number\">0</span>) count++;</span><br><span class=\"line\">        dfs(root.left,targetSum);</span><br><span class=\"line\">        dfs(root.right,targetSum);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>对前缀和解法的一点解释</strong></p>\n<p><a href=\"https://leetcode-cn.com/u/irrela-v/\">IrrelaL3</a>发布于 2021-02-078.6k<a href=\"https://leetcode-cn.com/tag/depth-first-search/\">深度优先搜索</a><a href=\"https://leetcode-cn.com/tag/hash-table/\">哈希表</a><a href=\"https://leetcode-cn.com/tag/backtracking/\">回溯</a><a href=\"https://leetcode-cn.com/topic/java/\">Java</a></p>\n<p><a href=\"https://leetcode-cn.com/problems/path-sum-iii/solution/qian-zhui-he-di-gui-hui-su-by-shi-huo-de-xia-tian/\">前缀和解法原址</a> 原作者: 失火的夏天</p>\n<p>在看这个解法的时候花了点时间，每个人理解方式有差异，写这个是希望能帮助到部分朋友。</p>\n<p>主要有四个地方会卡住：</p>\n<ul>\n<li>前缀和定义</li>\n<li>用它干什么</li>\n<li>HashMap存的是什么</li>\n<li>恢复状态代码的意义</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//恢复状态代码</span><br><span class=\"line\">prefixSumCount.put(currSum, prefixSumCount.get(currSum) - 1); </span><br></pre></td></tr></table></figure>\n\n<p><strong>前缀和定义</strong></p>\n<blockquote>\n<p>一个节点的前缀和就是<code>该节点</code>到<code>根</code>之间的路径和。</p>\n</blockquote>\n<p>拿下图解释：<br>节点4的前缀和为：1 + 2 + 4 = 7<br>节点8的前缀和：1 + 2 + 4 + 8 = 15<br>节点9的前缀和：1 + 2 + 5 + 9 = 17</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      1</span><br><span class=\"line\">     /  \\</span><br><span class=\"line\">    2    3</span><br><span class=\"line\">   / \\    \\</span><br><span class=\"line\">  4   5    6</span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\">7   8   9</span><br></pre></td></tr></table></figure>\n\n<p><strong>前缀和对于本题的作用</strong></p>\n<p>题目要求的是找出<code>路径和等于给定数值</code>的路径总数, 而:</p>\n<blockquote>\n<p>两节点间的路径和 = 两节点的前缀和之差</p>\n</blockquote>\n<p>还是拿下图解释：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      1</span><br><span class=\"line\">     / </span><br><span class=\"line\">    2    </span><br><span class=\"line\">   / </span><br><span class=\"line\">  3   </span><br><span class=\"line\"> / </span><br><span class=\"line\">4  </span><br></pre></td></tr></table></figure>\n\n<p>假如题目给定数值为5</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">节点1的前缀和为: 1节点3的前缀和为: 1 + 2 + 3 = 6prefix(3) - prefix(1) == 5所以 节点1 到 节点3 之间有一条符合要求的路径( 2 --&gt; 3 )</span><br></pre></td></tr></table></figure>\n\n<p>理解了这个之后，问题就得以简化：</p>\n<blockquote>\n<p>我们只用遍历整颗树一次，记录每个节点的前缀和，并查询该节点的祖先节点中符合条件的个数，将这个数量加到最终结果上。</p>\n</blockquote>\n<p><strong>HashMap存的是什么</strong></p>\n<p>HashMap的key是前缀和， value是该前缀和的节点数量，记录数量是因为有出现复数路径的可能。</p>\n<p>拿图说明：</p>\n<p>下图树中，前缀和为1的节点有两个: 1, 0</p>\n<p>所以路径和为2的路径数就有两条: 0 –&gt; 2, 2</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1     /     0   /  2</span><br></pre></td></tr></table></figure>\n\n<p><strong>恢复状态的意义</strong></p>\n<p>由于题目要求：<code>路径方向必须是向下的（只能从父节点到子节点）</code></p>\n<p>当我们讨论两个节点的前缀和差值时，有一个前提：</p>\n<blockquote>\n<p>一个节点必须是另一个节点的祖先节点</p>\n</blockquote>\n<p>换句话说，当我们把一个节点的前缀和信息更新到map里时，它应当只对其子节点们有效。</p>\n<p>举个例子，下图中有两个值为2的节点（A, B)。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      0</span><br><span class=\"line\">     /  \\</span><br><span class=\"line\">    A:2  B:2</span><br><span class=\"line\">   / \\    \\</span><br><span class=\"line\">  4   5    6</span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\">7   8   9</span><br></pre></td></tr></table></figure>\n\n<p>当我们遍历到最右方的节点6时，对于它来说，此时的前缀和为2的节点只该有B, 因为从A向下到不了节点6(A并不是节点6的祖先节点)。</p>\n<p>如果我们不做状态恢复，当遍历右子树时，左子树中A的信息仍会保留在map中，那此时节点6就会认为A, B都是可追溯到的节点，从而产生错误。</p>\n<p>状态恢复代码的作用就是： 在遍历完一个节点的所有子节点后，将其从map中除去。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;Integer,Integer&gt; mem = <span class=\"keyword\">new</span> HashMap&lt;Integer,Integer&gt;();<span class=\"comment\">//保存前缀树</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> target;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">pathSum</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> targetSum)</span> </span>&#123;</span><br><span class=\"line\">        target = targetSum;</span><br><span class=\"line\">        mem.put(<span class=\"number\">0</span>,<span class=\"number\">1</span>);<span class=\"comment\">//前缀树为0的个数至少是一个</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dfs(root,<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root,<span class=\"keyword\">int</span> curSum)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        curSum += root.val;<span class=\"comment\">//得到当前前缀树的值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = <span class=\"number\">0</span>;                            <span class=\"comment\">//getOrDefault() 方法获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值        key - 键  defaultValue - 当指定的key并不存在映射关系中，则返回的该默认值</span></span><br><span class=\"line\">        res = mem.getOrDefault(curSum-target,<span class=\"number\">0</span>);<span class=\"comment\">//得到我们想要前缀树的个数，想要前缀树值就是当前前缀树值减去目标值</span></span><br><span class=\"line\">        mem.put(curSum,mem.getOrDefault(curSum,<span class=\"number\">0</span>)+<span class=\"number\">1</span>);<span class=\"comment\">//将当前前缀树的值保存</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = dfs(root.left,curSum);<span class=\"comment\">//遍历左边</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = dfs(root.right,curSum);<span class=\"comment\">//遍历右边</span></span><br><span class=\"line\">        mem.put(curSum,mem.get(curSum)-<span class=\"number\">1</span>);<span class=\"comment\">//防止左边前缀树影响右边前缀树，左边前缀树可能有个为6，右边正好想要一个前缀树为6的，这样子就出错了</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> res+left+right;<span class=\"comment\">//结果是当前节点前缀树的个数加上左边满足的个数加右边满足的个数</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"572-另一个树的子树\"><a href=\"#572-另一个树的子树\" class=\"headerlink\" title=\"572. 另一个树的子树\"></a><a href=\"https://leetcode-cn.com/problems/subtree-of-another-tree/\">572. 另一个树的子树</a></h4><p>难度：简单</p>\n<p>给定两个非空二叉树 <strong>s</strong> 和 <strong>t</strong>，检验 <strong>s</strong> 中是否包含和 <strong>t</strong> 具有相同结构和节点值的子树。<strong>s</strong> 的一个子树包括 <strong>s</strong> 的一个节点和这个节点的所有子孙。<strong>s</strong> 也可以看做它自身的一棵子树。</p>\n<p><strong>示例 1:</strong><br>给定的树 s:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  4   5</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">1   2</span><br></pre></td></tr></table></figure>\n\n<p>给定的树 t：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  4 </span><br><span class=\"line\"> / \\</span><br><span class=\"line\">1   2</span><br></pre></td></tr></table></figure>\n\n<p>返回 <strong>true</strong>，因为 t 与 s 的一个子树拥有相同的结构和节点值。</p>\n<p><strong>示例 2:</strong><br>给定的树 s：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  4   5</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">1   2</span><br><span class=\"line\">   /</span><br><span class=\"line\">  0</span><br></pre></td></tr></table></figure>\n\n<p>给定的树 t：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  4</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">1   2</span><br></pre></td></tr></table></figure>\n\n<p>返回 <strong>false</strong>。</p>\n<p><strong>解析：</strong></p>\n<p><strong>方法一：深度优先搜索暴力匹配</strong></p>\n<p><strong>思路和算法</strong></p>\n<p>这是一种最朴素的方法——深度优先搜索枚举 <em>s</em> 中的每一个节点，判断这个点的子树是否和 <em>t</em> 相等。如何判断一个节点的子树是否和 <em>t</em> 相等呢，我们又需要做一次深度优先搜索来检查，即让两个指针一开始先指向该节点和 <em>t</em> 的根，然后「同步移动」两根指针来「同步遍历」这两棵树，判断对应位置是否相等。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/1.PNG\" alt=\"img\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/2.PNG\" alt=\"img\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/3.PNG\" alt=\"img\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/4.PNG\" alt=\"img\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/5.PNG\" alt=\"img\"></p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/572/6.PNG\" alt=\"img\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSubtree</span><span class=\"params\">(TreeNode root, TreeNode subRoot)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root== <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(root,subRoot) ||isSubtree(root.left,subRoot) || isSubtree(root.right,subRoot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">check</span><span class=\"params\">(TreeNode rt, TreeNode st)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rt == <span class=\"keyword\">null</span> &amp;&amp; st == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rt == <span class=\"keyword\">null</span> || st == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(rt.val != st.val) <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> check(rt.left,st.left) &amp;&amp; check(rt.right,st.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：对于每一个 <em>s</em> 上的点，都需要做一次深度优先搜索来和 <em>t</em> 匹配，匹配一次的时间代价是 <em>O</em>(∣<em>t</em>∣)，那么总的时间代价就是 <em>O</em>(∣<em>s</em>∣×∣<em>t</em>∣)。故渐进时间复杂度为 <em>O</em>(∣<em>s</em>∣×∣<em>t</em>∣)。</li>\n<li>空间复杂度：假设 <em>s</em> 深度为 <em>d</em> <em>s</em>，<em>t</em> 的深度为<em>d</em> <em>t</em>，任意时刻栈空间的最大使用代价是 <em>O</em>(max{<em>d</em> <em>s</em>,<em>d</em> <em>t</em>})。故渐进空间复杂度为<em>O</em>(max{<em>d</em> <em>s</em>,<em>d</em> <em>t</em>})。</li>\n</ul>\n<h4 id=\"101-对称二叉树\"><a href=\"#101-对称二叉树\" class=\"headerlink\" title=\"101. 对称二叉树\"></a><a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">101. 对称二叉树</a></h4><p>难度：简单</p>\n<p>给定一个二叉树，检查它是否是镜像对称的。</p>\n<p>例如，二叉树 <code>[1,2,2,3,4,4,3]</code> 是对称的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  2   2</span><br><span class=\"line\"> / \\ / \\</span><br><span class=\"line\">3  4 4  3</span><br></pre></td></tr></table></figure>\n\n<p>但是下面这个 <code>[1,2,2,null,3,null,3]</code> 则不是镜像对称的:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">  1</span><br><span class=\"line\"> / \\</span><br><span class=\"line\">2   2</span><br><span class=\"line\"> \\   \\</span><br><span class=\"line\"> 3    3</span><br></pre></td></tr></table></figure>\n\n<p><strong>进阶：</strong></p>\n<p>你可以运用递归和迭代两种方法解决这个问题吗？</p>\n<p><strong>方法一：递归</strong></p>\n<p><strong>思路和算法</strong></p>\n<p>如果一个树的左子树与右子树镜像对称，那么这个树是对称的。</p>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/101/101_fig1.PNG\" alt=\"fig1\"></p>\n<p>因此，该问题可以转化为：两个树在什么情况下互为镜像？</p>\n<p>如果同时满足下面的条件，两个树互为镜像：</p>\n<ul>\n<li>它们的两个根结点具有相同的值</li>\n<li>每个树的右子树都与另一个树的左子树镜像对称</li>\n</ul>\n<p><img src=\"https://assets.leetcode-cn.com/solution-static/101/101_fig2.PNG\" alt=\"fig2\"></p>\n<p>我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，<em>p</em> 指针和 <em>q</em> 指针一开始都指向这棵树的根，随后 <em>p</em> 右移时，<em>q</em> 左移，<em>p</em> 左移时，<em>q</em> 右移。每次检查当前 <em>p</em> 和 <em>q</em> 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<p>代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class=\"line\">        return check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean check(TreeNode p, TreeNode q) &#123;</span><br><span class=\"line\">        if (p == null &amp;&amp; q == null) &#123;</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if (p == null || q == null) &#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<p>假设树上一共 <em>n</em> 个节点。</p>\n<ul>\n<li>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 <em>O</em>(<em>n</em>)。</li>\n<li>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 <em>n</em>，故渐进空间复杂度为 <em>O</em>(<em>n</em>)。</li>\n</ul>\n<p><strong>方法二：迭代</strong></p>\n<p><strong>思路和算法</strong></p>\n<p>「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public boolean isSymmetric(TreeNode root) &#123;</span><br><span class=\"line\">        return check(root, root);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public boolean check(TreeNode u, TreeNode v) &#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; q = new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        q.offer(u);</span><br><span class=\"line\">        q.offer(v);</span><br><span class=\"line\">        while (!q.isEmpty()) &#123;</span><br><span class=\"line\">            u = q.poll();</span><br><span class=\"line\">            v = q.poll();</span><br><span class=\"line\">            if (u == null &amp;&amp; v == null) &#123;</span><br><span class=\"line\">                continue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if ((u == null || v == null) || (u.val != v.val)) &#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.left);</span><br><span class=\"line\">            q.offer(v.right);</span><br><span class=\"line\"></span><br><span class=\"line\">            q.offer(u.right);</span><br><span class=\"line\">            q.offer(v.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，同「方法一」。</li>\n<li>空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 <em>n</em> 个点，故渐进空间复杂度为 <em>O</em>(<em>n</em>)。</li>\n</ul>\n<h4 id=\"111-二叉树的最小深度\"><a href=\"#111-二叉树的最小深度\" class=\"headerlink\" title=\"111. 二叉树的最小深度\"></a><a href=\"https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/\">111. 二叉树的最小深度</a></h4><p>难度：简单</p>\n<p>给定一个二叉树，找出其最小深度。</p>\n<p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p>\n<p><strong>说明：</strong>叶子节点是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,9,20,null,null,15,7]</span><br><span class=\"line\">输出：2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [2,null,3,null,4,null,5,null,6]</span><br><span class=\"line\">输出：5</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数的范围在 <code>[0, 105]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n</ul>\n<p><strong>方法一：深度优先搜索</strong></p>\n<p><strong>思路及解法</strong></p>\n<p>首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。</p>\n<p>对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。</p>\n<p><strong>思路：</strong></p>\n<p>很多人写出的代码都不符合 <code>1,2</code> 这个测试用例，是因为没搞清楚题意</p>\n<p>题目中说明:叶子节点是指没有子节点的节点，这句话的意思是 1 不是叶子节点</p>\n<p>题目问的是到叶子节点的最短距离，所以所有返回结果为 1 当然不是这个结果</p>\n<p>另外这道题的关键是搞清楚递归结束条件</p>\n<ul>\n<li>叶子节点的定义是左孩子和右孩子都为 null 时叫做叶子节点</li>\n<li>当 root 节点左右孩子都为空时，返回 1</li>\n<li>当 root 节点左右孩子有一个为空时，返回不为空的孩子节点的深度</li>\n<li>当 root 节点左右孩子都不为空时，返回左右孩子较小深度的节点值</li>\n</ul>\n<p>第一版代码:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int minDepth(TreeNode root) &#123;</span><br><span class=\"line\">        if(root == null) return 0;</span><br><span class=\"line\">        //这道题递归条件里分为三种情况</span><br><span class=\"line\">        //1.左孩子和有孩子都为空的情况，说明到达了叶子节点，直接返回1即可</span><br><span class=\"line\">        if(root.left == null &amp;&amp; root.right == null) return 1;</span><br><span class=\"line\">        //2.如果左孩子和由孩子其中一个为空，那么需要返回比较大的那个孩子的深度        </span><br><span class=\"line\">        int m1 = minDepth(root.left);</span><br><span class=\"line\">        int m2 = minDepth(root.right);</span><br><span class=\"line\">        //这里其中一个节点为空，说明m1和m2有一个必然为0，所以可以返回m1 + m2 + 1;</span><br><span class=\"line\">        if(root.left == null || root.right == null) return m1 + m2 + 1;</span><br><span class=\"line\">        </span><br><span class=\"line\">        //3.最后一种情况，也就是左右孩子都不为空，返回最小深度+1即可</span><br><span class=\"line\">        return Math.min(m1,m2) + 1; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码可以进行简化，当左右孩子为空时 <em>m</em>1 和 <em>m</em>2 都为 0</p>\n<p>可以和情况 2 进行合并，即返回 m*1+*m2+1</p>\n<p>简化后代码如下:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m1 = minDepth(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> m2 = minDepth(root.right);</span><br><span class=\"line\">        <span class=\"comment\">//1.如果左孩子和右孩子有为空的情况，直接返回m1+m2+1</span></span><br><span class=\"line\">        <span class=\"comment\">//2.如果都不为空，返回较小深度+1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.left == <span class=\"keyword\">null</span> || root.right == <span class=\"keyword\">null</span> ? m1 + m2 + <span class=\"number\">1</span> : Math.min(m1,m2) + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<em>O</em>(<em>H</em>)，其中 <em>H</em> 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 <em>O</em>(<em>N</em>)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 <em>O</em>(log<em>N</em>)。</li>\n</ul>\n<p><strong>方法二：广度优先搜索</strong></p>\n<p><strong>思路及解法</strong></p>\n<p>同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。</p>\n<p>当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    class QueueNode &#123;</span><br><span class=\"line\">        TreeNode node;</span><br><span class=\"line\">        int depth;</span><br><span class=\"line\"></span><br><span class=\"line\">        public QueueNode(TreeNode node, int depth) &#123;</span><br><span class=\"line\">            this.node = node;</span><br><span class=\"line\">            this.depth = depth;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int minDepth(TreeNode root) &#123;</span><br><span class=\"line\">        if (root == null) &#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        Queue&lt;QueueNode&gt; queue = new LinkedList&lt;QueueNode&gt;();</span><br><span class=\"line\">        queue.offer(new QueueNode(root, 1));</span><br><span class=\"line\">        while (!queue.isEmpty()) &#123;</span><br><span class=\"line\">            QueueNode nodeDepth = queue.poll();</span><br><span class=\"line\">            TreeNode node = nodeDepth.node;</span><br><span class=\"line\">            int depth = nodeDepth.depth;</span><br><span class=\"line\">            if (node.left == null &amp;&amp; node.right == null) &#123;</span><br><span class=\"line\">                return depth;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (node.left != null) &#123;</span><br><span class=\"line\">                queue.offer(new QueueNode(node.left, depth + 1));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if (node.right != null) &#123;</span><br><span class=\"line\">                queue.offer(new QueueNode(node.right, depth + 1));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。对每个节点访问一次。</li>\n<li>空间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。</li>\n</ul>\n<h4 id=\"404-左叶子之和\"><a href=\"#404-左叶子之和\" class=\"headerlink\" title=\"404. 左叶子之和\"></a><a href=\"https://leetcode-cn.com/problems/sum-of-left-leaves/\">404. 左叶子之和</a></h4><p>难度：简单</p>\n<p>计算给定二叉树的所有左叶子之和。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\"></span><br><span class=\"line\">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>\n\n<p>一个节点为「左叶子」节点，当且仅当它是某个节点的左子节点，并且它是一个叶子结点。因此我们可以考虑对整棵树进行遍历，当我们遍历到节点 <em>node</em> 时，如果它的左子节点是一个叶子结点，那么就将它的左子节点的值累加计入答案。</p>\n<p>遍历整棵树的方法有深度优先搜索和广度优先搜索，下面分别给出了实现代码。</p>\n<p><strong>方法一：深度优先搜索</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root != <span class=\"keyword\">null</span> ? dfs(root) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            ans += isLeafNode(node.left) ? node.left.val : dfs(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span> &amp;&amp; !isLeafNode(node.right)) &#123;</span><br><span class=\"line\">            ans += dfs(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLeafNode</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left == <span class=\"keyword\">null</span> &amp;&amp; node.right == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>改进代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">sumOfLeftLeaves</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> ) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isLeaf(root.left))  <span class=\"keyword\">return</span> root.left.val + sumOfLeftLeaves(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLeaf</span><span class=\"params\">(TreeNode node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>)  <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.left == <span class=\"keyword\">null</span> &amp;&amp; node.right == <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是树中的节点个数。</li>\n<li>空间复杂度：<em>O</em>(<em>n</em>)。空间复杂度与深度优先搜索使用的栈的最大深度相关。在最坏的情况下，树呈现链式结构，深度为 <em>O</em>(<em>n</em>)，对应的空间复杂度也为 <em>O</em>(<em>n</em>)。</li>\n</ul>\n<h4 id=\"687-最长同值路径\"><a href=\"#687-最长同值路径\" class=\"headerlink\" title=\"687. 最长同值路径\"></a><a href=\"https://leetcode-cn.com/problems/longest-univalue-path/\">687. 最长同值路径</a></h4><p>难度:中等</p>\n<p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p>\n<p><strong>注意</strong>：两个节点之间的路径长度由它们之间的边数表示。</p>\n<p><strong>示例 1:</strong></p>\n<p>输入:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    5</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  4   5</span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\">1   1   5</span><br></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<p>输入:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">    1</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  4   5</span><br><span class=\"line\"> / \\   \\</span><br><span class=\"line\">4   4   5</span><br></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong> 给定的二叉树不超过10000个结点。 树的高度不超过1000。</p>\n<p><strong>方法：递归</strong></p>\n<p><strong>思路</strong></p>\n<p>我们可以将任何路径（具有相同值的节点）看作是最多两个从其根延伸出的箭头。</p>\n<p>具体地说，路径的根将是唯一节点，因此该节点的父节点不会出现在该路径中，而箭头将是根在该路径中只有一个子节点的路径。</p>\n<p>然后，对于每个节点，我们想知道向左延伸的最长箭头和向右延伸的最长箭头是什么？我们可以用递归来解决这个问题。</p>\n<p><strong>算法</strong></p>\n<p>令 <code>arrow_length(node)</code> 为从节点 <code>node</code> 延伸出的最长箭头的长度。如果 <code>node.Left</code> 存在且与节点 <code>node</code> 具有相同的值，则该值就会是 <code>1 + arrow_length(node.left)</code>。在 <code>node.right</code> 存在的情况下也是一样。</p>\n<p>当我们计算箭头长度时，候选答案将是该节点在两个方向上的箭头之和。我们将这些候选答案记录下来，并返回最佳答案。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ans;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestUnivaluePath</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        arrowLength(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">arrowLength</span><span class=\"params\">(TreeNode node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = arrowLength(node.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = arrowLength(node.right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> arrowLeft = <span class=\"number\">0</span>, arrowRight = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.left != <span class=\"keyword\">null</span> &amp;&amp; node.left.val == node.val) &#123;</span><br><span class=\"line\">            arrowLeft += left + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.right != <span class=\"keyword\">null</span> &amp;&amp; node.right.val == node.val) &#123;</span><br><span class=\"line\">            arrowRight += right + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> path = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">longestUnivaluePath</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode root)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = dfs(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right =dfs(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> leftPath  = root.left != <span class=\"keyword\">null</span> &amp;&amp; root.left.val == root.val ? left + <span class=\"number\">1</span>:<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rightPath = root.right != <span class=\"keyword\">null</span> &amp;&amp; root.right.val == root.val ?right +<span class=\"number\">1</span> :<span class=\"number\">0</span>;</span><br><span class=\"line\">        path = Math.max(path,leftPath+rightPath);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(leftPath,rightPath);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>以上这个代码是自己写的改进代码</strong></p>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是树中节点数。我们处理每个节点一次。</li>\n<li>空间复杂度：<em>O</em>(<em>H</em>)，其中 <em>H</em> 是树的高度。我们的递归调用栈可以达到 <em>H</em> 层的深度。</li>\n</ul>\n<h4 id=\"337-打家劫舍-III\"><a href=\"#337-打家劫舍-III\" class=\"headerlink\" title=\"337. 打家劫舍 III\"></a><a href=\"https://leetcode-cn.com/problems/house-robber-iii/\">337. 打家劫舍 III</a></h4><p>难度：中等</p>\n<p>在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。</p>\n<p>计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [3,2,3,null,3,null,1]</span><br><span class=\"line\"></span><br><span class=\"line\">     3</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">   2   3</span><br><span class=\"line\">    \\   \\ </span><br><span class=\"line\">     3   1</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 7 </span><br><span class=\"line\">解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [3,4,5,1,3,null,1]</span><br><span class=\"line\"></span><br><span class=\"line\">     3</span><br><span class=\"line\">    / \\</span><br><span class=\"line\">   4   5</span><br><span class=\"line\">  / \\   \\ </span><br><span class=\"line\"> 1   3   1</span><br><span class=\"line\"></span><br><span class=\"line\">输出: 9</span><br><span class=\"line\">解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>解析：</strong></p>\n<p>自己写的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Map&lt;TreeNode,Integer&gt; cache = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cache.containsKey(root)) <span class=\"keyword\">return</span> cache.get(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val1 = root.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left!= <span class=\"keyword\">null</span>) val1 +=rob(root.left.left) + rob(root.left.right);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right!=<span class=\"keyword\">null</span>) val1 += rob(root.right.left) + rob(root.right.right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> val2 =rob(root.left) + rob(root.right);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> res = Math.max(val1,val2);</span><br><span class=\"line\">        cache.put(root,res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过三个方法不断递进解决问题</p>\n<ul>\n<li>解法一通过递归实现，虽然解决了问题，但是复杂度太高</li>\n<li>解法二通过解决方法一中的重复子问题，实现了性能的百倍提升</li>\n<li>解法三直接省去了重复子问题，性能又提升了一步</li>\n</ul>\n<p><strong>解法一、暴力递归 - 最优子结构</strong></p>\n<p>在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题<br>首先来定义这个问题的状态<br>爷爷节点获取到最大的偷取的钱数呢</p>\n<ol>\n<li>首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷</li>\n<li>二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子</li>\n</ol>\n<p>根据以上条件，我们可以得出单个节点的钱该怎么算<br><strong>4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构</strong></p>\n<p>由于是二叉树，这里可以选择计算所有子节点</p>\n<p>4 个孙子投的钱加上爷爷的钱如下<br><code>int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)</code><br>两个儿子偷的钱如下<br><code>int method2 = rob(root.left) + rob(root.right);</code><br>挑选一个钱数多的方案则<br><code>int result = Math.max(method1, method2);</code><br>将上述方案写成代码如下</p>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public int rob(TreeNode root) &#123;</span><br><span class=\"line\">    if (root == null) return 0;</span><br><span class=\"line\"></span><br><span class=\"line\">    int money = root.val;</span><br><span class=\"line\">    if (root.left != null) &#123;</span><br><span class=\"line\">        money += (rob(root.left.left) + rob(root.left.right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (root.right != null) &#123;</span><br><span class=\"line\">        money += (rob(root.right.left) + rob(root.right.right));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    return Math.max(money, rob(root.left) + rob(root.right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>信心满满的提交，一次通过，然而 <strong>执行用时:837 ms,在所有 java 提交中击败了24.49%的用户</strong> 这个结果太没面子了，下个解法进行优化</p>\n<p><strong>解法二、记忆化 - 解决重复子问题</strong></p>\n<p>针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。</p>\n<p>于是乎我们发现了一个动态规划的关键优化点</p>\n<p><strong>重复子问题</strong></p>\n<p>我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。<br>由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value</p>\n<p>解法一加上记忆化优化后代码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    HashMap&lt;TreeNode, Integer&gt; memo = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> robInternal(root, memo);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">robInternal</span><span class=\"params\">(TreeNode root, HashMap&lt;TreeNode, Integer&gt; memo)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (memo.containsKey(root)) <span class=\"keyword\">return</span> memo.get(root);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> money = root.val;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.left != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root.right != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));</span><br><span class=\"line\">    memo.put(root, result);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>提交代码，<code>执行用时：4 ms, 在所有 java 提交中击败了 54.92% 的用户</code>，速度提高了 200 倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。</p>\n<p><strong>解法三、终极解法</strong></p>\n<p>上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。</p>\n<p>我们换一种办法来定义此问题</p>\n<p>每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷</p>\n<ul>\n<li>当前节点选择偷时，那么两个孩子节点就不能选择偷了</li>\n<li>当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)</li>\n</ul>\n<p>我们使用一个大小为 2 的数组来表示 <code>int[] res = new int[2]</code> 0 代表不偷，1 代表偷<br><strong>任何一个节点能偷到的最大钱的状态可以定义为</strong></p>\n<ol>\n<li>当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱</li>\n<li>当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数</li>\n</ol>\n<p>表示为公式如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])</span><br><span class=\"line\">root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;</span><br></pre></td></tr></table></figure>\n\n<p>将公式做个变换就是代码啦</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">rob</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] result = robInternal(root);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Math.max(result[<span class=\"number\">0</span>], result[<span class=\"number\">1</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] robInternal(TreeNode root) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[<span class=\"number\">2</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] left = robInternal(root.left);</span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] right = robInternal(root.right);</span><br><span class=\"line\"></span><br><span class=\"line\">    result[<span class=\"number\">0</span>] = Math.max(left[<span class=\"number\">0</span>], left[<span class=\"number\">1</span>]) + Math.max(right[<span class=\"number\">0</span>], right[<span class=\"number\">1</span>]);</span><br><span class=\"line\">    result[<span class=\"number\">1</span>] = left[<span class=\"number\">0</span>] + right[<span class=\"number\">0</span>] + root.val;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>再提交一次：<br><strong>执行用时 1 ms, 在所有 java 提交中击败了 99.87% 的用户</strong>，这样的结果，我觉得可以了。</p>\n<h4 id=\"671-二叉树中第二小的节点\"><a href=\"#671-二叉树中第二小的节点\" class=\"headerlink\" title=\"671. 二叉树中第二小的节点\"></a><a href=\"https://leetcode-cn.com/problems/second-minimum-node-in-a-binary-tree/\">671. 二叉树中第二小的节点</a></h4><p>难度：简单</p>\n<p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 <code>2</code> 或 <code>0</code>。如果一个节点有两个子节点的话，那么该节点的值等于两个子节点中较小的一个。</p>\n<p>更正式地说，<code>root.val = min(root.left.val, root.right.val)</code> 总成立。</p>\n<p>给出这样的一个二叉树，你需要输出所有节点中的<strong>第二小的值。</strong>如果第二小的值不存在的话，输出 -1 <strong>。</strong></p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [2,2,5,null,null,5,7]</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：最小的值是 2 ，第二小的值是 5 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [2,2,2]输出：-1解释：最小的值是 2, 但是不存在第二小的值。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[1, 25]</code> 内</li>\n<li><code>1 &lt;= Node.val &lt;= 231 - 1</code></li>\n<li>对于树中每个节点 <code>root.val == min(root.left.val, root.right.val)</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findSecondMinimumValue</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span> || (root.left == <span class=\"keyword\">null</span> &amp;&amp; root.right == <span class=\"keyword\">null</span>)) <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;<span class=\"comment\">//没有最小节点</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//找出候选数，默认就是子节点值，如果子节点值和root值相同，递归，在子树中寻找候选数</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = root.left.val;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = root.right.val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.left.val == root.val) left = findSecondMinimumValue(root.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.right.val == root.val) right = findSecondMinimumValue(root.right);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果左右候选数都正常，返回较小值就可</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != -<span class=\"number\">1</span> &amp;&amp; right != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">//什么时候left == -1 ？ root.left 为根节点的子树的节点值全部相同，且root.left.val==root.val。那么自然这颗子树没有第二小的节点。</span></span><br><span class=\"line\">    <span class=\"comment\">//什么时候left != -1 ? root.left 为根节点的子树中有node.val【大于】root.val的节点，第一小的节点值root.val。</span></span><br><span class=\"line\">    <span class=\"comment\">//left是【以root.left为根节点的子树==左子树】中第二的值，该值【大于】root.val</span></span><br><span class=\"line\">    <span class=\"comment\">//right是【以root.right为根节点的子树==右子树】中最小的值，该值【大于】root.val</span></span><br><span class=\"line\">    <span class=\"comment\">//在 left、right、root.val 三个值当中，root.val一定是最小的</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> Math.min(left, right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果候选数有-1，说明整个子树中没有可供候选的数</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != -<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//左子树正常，答案就是左边的候选数</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> left;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//右子树正常，返回答案</span></span><br><span class=\"line\">            <span class=\"comment\">//或者右子树也没有候选数，返回-1，即right</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"层次遍历\"><a href=\"#层次遍历\" class=\"headerlink\" title=\"层次遍历\"></a>层次遍历</h2><p>使用BFS进行层次遍历。不需要使用两个队列来分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p>\n<h4 id=\"637-二叉树的层平均值\"><a href=\"#637-二叉树的层平均值\" class=\"headerlink\" title=\"637. 二叉树的层平均值\"></a><a href=\"https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\">637. 二叉树的层平均值</a></h4><p>难度：简单</p>\n<p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>\n<p><strong>示例 1：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\">    3</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  9  20</span><br><span class=\"line\">    /  \\</span><br><span class=\"line\">   15   7</span><br><span class=\"line\">输出：[3, 14.5, 11]</span><br><span class=\"line\">解释：</span><br><span class=\"line\">第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>节点值的范围在32位有符号整数范围内。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p>方法二：广度优先搜索<br>也可以使用广度优先搜索计算二叉树的层平均值。从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。</p>\n<p>如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下：</p>\n<p>初始时，将根节点加入队列；</p>\n<p>每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。</p>\n<p>由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。</p>\n<p>具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 size，遍历时只遍历 size 个节点，即可满足每一轮遍历的是同一层的全部节点。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Double&gt; <span class=\"title\">averageOfLevels</span><span class=\"params\">(TreeNode root)</span> </span>&#123;   <span class=\"comment\">//List 集合中的List接口，存储有序的、可重复的数据</span></span><br><span class=\"line\">        List&lt;Double&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue =  <span class=\"keyword\">new</span> LinkedList&lt;&gt;(); </span><br><span class=\"line\">        <span class=\"comment\">//LinkedList 实现了 Queue 接口，可作为队列使用</span></span><br><span class=\"line\">        <span class=\"comment\">//public E poll()\t删除并返回第一个元素。 也可称出队列</span></span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> cnt = queue.size();</span><br><span class=\"line\">            <span class=\"keyword\">double</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>;i&lt;cnt;i++)&#123;</span><br><span class=\"line\">                TreeNode node = queue.poll();</span><br><span class=\"line\">                sum += node.val;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.left != <span class=\"keyword\">null</span>) queue.add(node.left);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node.right != <span class=\"keyword\">null</span> ) queue.add(node.right);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ret.add(sum / cnt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。<br>广度优先搜索需要对每个节点访问一次，时间复杂度是 O(n)。<br>需要对二叉树的每一层计算平均值，时间复杂度是 O(h)，其中 h 是二叉树的高度，任何情况下都满足 h≤n。<br>因此总时间复杂度是 O(n)。</p>\n<p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度取决于队列开销，队列中的节点个数不会超过 n。</p>\n<h4 id=\"513-找树左下角的值\"><a href=\"#513-找树左下角的值\" class=\"headerlink\" title=\"513. 找树左下角的值\"></a><a href=\"https://leetcode-cn.com/problems/find-bottom-left-tree-value/\">513. 找树左下角的值</a></h4><p>难度：中等</p>\n<p>给定一个二叉树，在树的最后一行找到最左边的值。</p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\"></span><br><span class=\"line\">    2</span><br><span class=\"line\">   / \\</span><br><span class=\"line\">  1   3</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入:</span><br><span class=\"line\"></span><br><span class=\"line\">        1</span><br><span class=\"line\">       / \\</span><br><span class=\"line\">      2   3</span><br><span class=\"line\">     /   / \\</span><br><span class=\"line\">    4   5   6</span><br><span class=\"line\">       /</span><br><span class=\"line\">      7</span><br><span class=\"line\"></span><br><span class=\"line\">输出:</span><br><span class=\"line\">7</span><br></pre></td></tr></table></figure>\n\n<p><strong>注意:</strong> 您可以假设树（即给定的根节点）不为 <strong>NULL</strong>。</p>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">          root = queue.poll();</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(root.right != <span class=\"keyword\">null</span>) queue.add(root.right);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(root.left != <span class=\"keyword\">null</span>)  queue.add(root.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种写法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">findBottomLeftValue</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        Queue&lt;TreeNode&gt; queue = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        TreeNode node = <span class=\"keyword\">null</span> ;</span><br><span class=\"line\">        queue.add(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!queue.isEmpty())&#123;</span><br><span class=\"line\">          node = queue.poll();</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(node.right != <span class=\"keyword\">null</span>) queue.add(node.right);</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(node.left != <span class=\"keyword\">null</span>)  queue.add(node.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node.val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"前中后序遍历\"><a href=\"#前中后序遍历\" class=\"headerlink\" title=\"前中后序遍历\"></a>前中后序遍历</h2><h4 id=\"144-二叉树的前序遍历\"><a href=\"#144-二叉树的前序遍历\" class=\"headerlink\" title=\"144. 二叉树的前序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">144. 二叉树的前序遍历</a></h4><p>难度：简单</p>\n<p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1]</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]</span><br><span class=\"line\">输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p>\n<p><strong>解析</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">preorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; ret  =  <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack   = <span class=\"keyword\">new</span> Stack&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;<span class=\"comment\">//如果为空 则结束当前循环</span></span><br><span class=\"line\">            ret.add(node.val);</span><br><span class=\"line\">            stack.push(node.right);</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<p><strong>递归解法</strong></p>\n<p><strong>前序遍历</strong></p>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void preOrderRecur(TreeNode head) &#123;</span><br><span class=\"line\">    if (head == null) &#123;</span><br><span class=\"line\">        return;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    System.out.print(head.value + &quot; &quot;);</span><br><span class=\"line\">    preOrderRecur(head.left);</span><br><span class=\"line\">    preOrderRecur(head.right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>中序遍历</strong></p>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void preOrderRecur(TreeNode head) &#123;    if (head == null) &#123;        return;    &#125;    preOrderRecur(head.left);    System.out.print(head.value + &quot; &quot;);    preOrderRecur(head.right);&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>后序遍历</strong></p>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void postOrderRecur(TreeNode head) &#123;    if (head == null) &#123;        return;    &#125;    postOrderRecur(head.left);    postOrderRecur(head.right);    System.out.print(head.value + &quot; &quot;);&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>代码解释</strong></p>\n<p>这里没有对递归遍历做过多的解释，仅仅给出了简单的动画演示。<br>要理解递归的思路并且熟练的使用它，就是要<em>想清楚你想做什么，什么时候停止</em>。</p>\n<p><strong>如前序遍历：</strong><br>我想先打印头节点对吧？那我打印完了头节点，我现在想打印左边节点了，我只是告诉计算机我想打印左边结点，之后打印右边结点。</p>\n<p><strong>那么后序遍历呢？</strong><br>这个时候你应该知道了，我就是想操作左边然后右边，最后打印中间的元素。</p>\n<p>我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。</p>\n<blockquote>\n<p>计算机都可能溢出，用人脑去遍历就不现实了。</p>\n</blockquote>\n<hr>\n<p><strong>迭代解法</strong></p>\n<p>本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用<code>Stack</code>来模拟系统栈。</p>\n<p><strong>前序遍历</strong></p>\n<p>首先我们应该创建一个<code>Stack</code>用来存放节点，首先我们想要打印根节点的数据，此时<code>Stack</code>里面的内容为空，所以我们优先将头结点加入<code>Stack</code>，然后打印。</p>\n<p>之后我们应该先打印左子树，然后右子树。所以先加入<code>Stack</code>的就是右子树，然后左子树。<br>此时你能得到的流程如下:</p>\n<p><img src=\"https://pic.leetcode-cn.com/6233a9685447d0b4d7b513f739151ca065e5697e24070bcafc1ee5d28f9155a6.png\" alt=\"中序遍历流程图\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void preOrderIteration(TreeNode head) &#123;</span><br><span class=\"line\">\tif (head == null) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tStack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">\tstack.push(head);</span><br><span class=\"line\">\twhile (!stack.isEmpty()) &#123;</span><br><span class=\"line\">\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\tSystem.out.print(node.value + &quot; &quot;);</span><br><span class=\"line\">\t\tif (node.right != null) &#123;</span><br><span class=\"line\">\t\t\tstack.push(node.right);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tif (node.left != null) &#123;</span><br><span class=\"line\">\t\t\tstack.push(node.left);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>中序遍历</strong></p>\n<ol>\n<li>同理创建一个<code>Stack</code>，然后按 左 中 右的顺序输出节点。</li>\n<li>尽可能的将这个节点的左子树压入<code>Stack</code>，此时栈顶的元素是最左侧的元素，<em>其目的是找到一个最小单位的子树(也就是最左侧的一个节点)，并且在寻找的过程中记录了来源，才能返回上层</em>,同时在返回上层的时候已经处理完毕左子树了。。</li>\n<li>当处理完最小单位的子树时，返回到上层处理了中间节点。（如果把整个左中右的遍历都理解成子树的话，就是处理完 <code>左子树-&gt;中间(就是一个节点)-&gt;右子树</code>）</li>\n<li>如果有右节点，其也要进行中序遍历。<br><img src=\"https://pic.leetcode-cn.com/06eddcac9277efdbbd338b5069e836bbb2e8eb4c4fbf145025f3ab1a52263912.png\" alt=\"中序遍历\"><br>当整个左子树退栈的时候这个时候输出了该子树的根节点 2，之后输出中间节点 1。然后处理根节点为3右子树。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void inOrderIteration(TreeNode head) &#123;</span><br><span class=\"line\">\tif (head == null) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode cur = head;</span><br><span class=\"line\">\tStack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class=\"line\">\twhile (!stack.isEmpty() || cur != null) &#123;</span><br><span class=\"line\">\t\twhile (cur != null) &#123;</span><br><span class=\"line\">\t\t\tstack.push(cur);</span><br><span class=\"line\">\t\t\tcur = cur.left;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tTreeNode node = stack.pop();</span><br><span class=\"line\">\t\tSystem.out.print(node.value + &quot; &quot;);</span><br><span class=\"line\">\t\tif (node.right != null) &#123;</span><br><span class=\"line\">\t\t\tcur = node.right;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>后序遍历</strong></p>\n<p><strong>代码片段 1</strong></p>\n<ol>\n<li>前序遍历的过程 是 中左右。</li>\n<li>将其转化成 中右左。也就是压栈的过程中优先压入左子树，在压入右子树。</li>\n<li>然后将这个结果返回来，这里是利用栈的先进后出倒序打印。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void postOrderIteration(TreeNode head) &#123;</span><br><span class=\"line\">\t\tif (head == null) &#123;</span><br><span class=\"line\">\t\t\treturn;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tStack&lt;TreeNode&gt; stack1 = new Stack&lt;&gt;();</span><br><span class=\"line\">\t\tStack&lt;TreeNode&gt; stack2 = new Stack&lt;&gt;();</span><br><span class=\"line\">\t\tstack1.push(head);</span><br><span class=\"line\">\t\twhile (!stack1.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\tTreeNode node = stack1.pop();</span><br><span class=\"line\">\t\t\tstack2.push(node);</span><br><span class=\"line\">\t\t\tif (node.left != null) &#123;</span><br><span class=\"line\">\t\t\t\tstack1.push(node.left);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (node.right != null) &#123;</span><br><span class=\"line\">\t\t\t\tstack1.push(node.right);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\twhile (!stack2.isEmpty()) &#123;</span><br><span class=\"line\">\t\t\tSystem.out.print(stack2.pop().value + &quot; &quot;);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>代码片段 2</strong></p>\n<ol>\n<li>用一个指针<code>cur</code>标记当前退出的节点是什么。</li>\n<li>后序遍历的过程中在遍历完左子树跟右子树<code>cur</code>都会回到根结点。所以当前不管是从左子树还是右子树回到根结点都不应该再操作了，应该退回上层。</li>\n<li>如果是从右边再返回根结点，应该回到上层。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void postOrderIteration2(TreeNode head) &#123; 感谢[@ben-ben-niu](/u/ben-ben-niu/)指出错误，代码确实存在问题，已经在原文中修复\tif (head == null) &#123;\t\treturn;\t&#125;\tTreeNode cur = head;\tStack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\tstack.push(head);\twhile (!stack.isEmpty()) &#123;\t\tTreeNode peek = stack.peek();\t\tif (peek.left != null &amp;&amp; peek.left != cur &amp;&amp; peek.right != cur) &#123;\t\t\tstack.push(peek.left);\t\t&#125; else if (peek.right != null &amp;&amp; peek.right != cur) &#123;\t\t\tstack.push(peek.right);\t\t&#125; else &#123;\t\t\tSystem.out.print(stack.pop().val + &quot; &quot;);\t\t\tcur = peek;\t\t&#125;\t&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>Morris解法</strong></p>\n<p><code>Morris</code>遍历使用二叉树节点中大量指向<code>null</code>的指针，由Joseph Morris 于1979年发明。<br>时间复杂度：<em>O</em>(<em>n</em>)<br>额外空间复杂度：<em>O</em>(1)</p>\n<p>在你阅读以下代码之前，在这边先讲解一下<code>Morris</code>的通用解法过程。<br><img src=\"https://pic.leetcode-cn.com/143b40666eebb8992b1ed7e6c35d4d5f3b93c6f20ab436e5c9ffa54032c392c0.png\" alt=\"在这里插入图片描述\"></p>\n<p><code>Morris</code>的整体思路就是将 <em>以某个根结点开始，找到它左子树的最右侧节点之后与这个根结点进行连接</em><br>我们可以从 <strong>图2</strong> 看到，如果这么连接之后，<strong>cur</strong> 这个指针是可以完整的从一个节点顺着下一个节点遍历，将整棵树遍历完毕，直到 <strong>7</strong> 这个节点右侧没有指向。</p>\n<ul>\n<li>Java</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void preOrderMorris(TreeNode head) &#123;\tif (head == null) &#123;\t\treturn;\t&#125;\tTreeNode cur1 = head;//当前开始遍历的节点\tTreeNode cur2 = null;//记录当前结点的左子树\twhile (cur1 != null) &#123;\t\tcur2 = cur1.left;\t\tif (cur2 != null) &#123;\t\t\twhile (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;//找到当前左子树的最右侧节点，且这个节点应该在指向根结点之前，否则整个节点又回到了根结点。\t\t\t\tcur2 = cur2.right;\t\t\t&#125;\t\t\tif (cur2.right == null) &#123;//这个时候如果最右侧这个节点的右指针没有指向根结点，创建连接然后往下一个左子树的根结点进行连接操作。\t\t\t\tcur2.right = cur1;\t\t\t\tcur1 = cur1.left;\t\t\t\tcontinue;\t\t\t&#125; else &#123;//当左子树的最右侧节点有指向根结点，此时说明我们已经回到了根结点并重复了之前的操作，同时在回到根结点的时候我们应该已经处理完 左子树的最右侧节点 了，把路断开。\t\t\t\tcur2.right = null;\t\t\t&#125;\t\t&#125; \t\tcur1 = cur1.right;//一直往右边走，参考图\t&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>前序遍历</strong></p>\n<ol>\n<li>在某个根结点创建连线的时候打印。因为我们是顺着左边的根节点来创建连线，且创建的过程只有一次。</li>\n<li>打印某些自身无法创建连线的节点，也就是叶子节点。</li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void preOrderMorris(TreeNode head) &#123;\tif (head == null) &#123;\t\treturn;\t&#125;\tTreeNode cur1 = head;\tTreeNode cur2 = null;\twhile (cur1 != null) &#123;\t\tcur2 = cur1.left;\t\tif (cur2 != null) &#123;\t\t\twhile (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;\t\t\t\tcur2 = cur2.right;\t\t\t&#125;\t\t\tif (cur2.right == null) &#123;\t\t\t\tcur2.right = cur1;\t\t\t\tSystem.out.print(cur1.value + &quot; &quot;);\t\t\t\tcur1 = cur1.left;\t\t\t\tcontinue;\t\t\t&#125; else &#123;\t\t\t\tcur2.right = null;\t\t\t&#125;\t\t&#125; else &#123;\t\t\tSystem.out.print(cur1.value + &quot; &quot;);\t\t&#125;\t\tcur1 = cur1.right;\t&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>中序遍历</strong></p>\n<p>从最左侧开始顺着右节点打印。也就是在将cu1切换到上层节点的时候。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">public static void inOrderMorris(TreeNode head) &#123;\tif (head == null) &#123;\t\treturn;\t&#125;\tTreeNode cur1 = head;\tTreeNode cur2 = null;\twhile (cur1 != null) &#123;\t\tcur2 = cur1.left;\t\t//构建连接线\t\tif (cur2 != null) &#123;\t\t\twhile (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;\t\t\t\tcur2 = cur2.right;\t\t\t&#125;\t\t\tif (cur2.right == null) &#123;\t\t\t\tcur2.right = cur1;\t\t\t\tcur1 = cur1.left;\t\t\t\tcontinue;\t\t\t&#125; else &#123;\t\t\t\tcur2.right = null;\t\t\t&#125;\t\t&#125;\t\tSystem.out.print(cur1.value + &quot; &quot;);\t\tcur1 = cur1.right;\t&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>后序遍历</strong></p>\n<p>后序遍历就比较复杂了哈，先看一下图<br><img src=\"https://pic.leetcode-cn.com/4b023cabcbfc58580127db3bd244a6b9d7f1060b899faa510c7366a5a51cce45.png\" alt=\"在这里插入图片描述\"></p>\n<p>当我们到达最左侧，也就是左边连线已经创建完毕了。<br>打印 4<br>打印 5 2<br>打印 6<br>打印 7 3 1<br>我们将一个节点的连续右节点当成一个单链表来看待。<br>当我们返回上层之后，也就是将连线断开的时候，打印下层的单链表。<br>比如返回到　２，此时打印　４<br>比如返回到　１，此时打印　５　２<br>比如返回到　３，此时打印　６<br>那么我们只需要将这个单链表逆序打印就行了，下文也给出了 <strong>单链表逆序代码</strong><br><em>这里不应该打印当前层，而是下一层，否则根结点会先与右边打印。</em></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">//后序Morris</span><br><span class=\"line\">public static void postOrderMorris(TreeNode head) &#123;</span><br><span class=\"line\">\tif (head == null) &#123;</span><br><span class=\"line\">\t\treturn;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tTreeNode cur1 = head;//遍历树的指针变量</span><br><span class=\"line\">\tTreeNode cur2 = null;//当前子树的最右节点</span><br><span class=\"line\">\twhile (cur1 != null) &#123;</span><br><span class=\"line\">\t\tcur2 = cur1.left;</span><br><span class=\"line\">\t\tif (cur2 != null) &#123;</span><br><span class=\"line\">\t\t\twhile (cur2.right != null &amp;&amp; cur2.right != cur1) &#123;</span><br><span class=\"line\">\t\t\t\tcur2 = cur2.right;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t\tif (cur2.right == null) &#123;</span><br><span class=\"line\">\t\t\t\tcur2.right = cur1;</span><br><span class=\"line\">\t\t\t\tcur1 = cur1.left;</span><br><span class=\"line\">\t\t\t\tcontinue;</span><br><span class=\"line\">\t\t\t&#125; else &#123;</span><br><span class=\"line\">\t\t\t\tcur2.right = null;</span><br><span class=\"line\">\t\t\t\tpostMorrisPrint(cur1.left);</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\tcur1 = cur1.right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpostMorrisPrint(head);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//打印函数</span><br><span class=\"line\">public static void postMorrisPrint(TreeNode head) &#123;</span><br><span class=\"line\">\tTreeNode reverseList = postMorrisReverseList(head);</span><br><span class=\"line\">\tTreeNode cur = reverseList;</span><br><span class=\"line\">\twhile (cur != null) &#123;</span><br><span class=\"line\">\t\tSystem.out.print(cur.value + &quot; &quot;);</span><br><span class=\"line\">\t\tcur = cur.right;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tpostMorrisReverseList(reverseList);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//翻转单链表</span><br><span class=\"line\">public static TreeNode postMorrisReverseList(TreeNode head) &#123;</span><br><span class=\"line\">\tTreeNode cur = head;</span><br><span class=\"line\">\tTreeNode pre = null;</span><br><span class=\"line\">\twhile (cur != null) &#123;</span><br><span class=\"line\">\t\tTreeNode next = cur.right;</span><br><span class=\"line\">\t\tcur.right = pre;</span><br><span class=\"line\">\t\tpre = cur;</span><br><span class=\"line\">\t\tcur = next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\treturn pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"94-二叉树的中序遍历\"><a href=\"#94-二叉树的中序遍历\" class=\"headerlink\" title=\"94. 二叉树的中序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">94. 二叉树的中序遍历</a></h4><p>难度：简单</p>\n<p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2,3]</span><br><span class=\"line\">输出：[1,3,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = []</span><br><span class=\"line\">输出：[]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1]输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2]输出：[2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/15/inorder_4.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2]输出：[1,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[0, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; ret  = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> ret;<span class=\"comment\">//注释掉也可以 但主要是为了严谨性。</span></span><br><span class=\"line\">        Stack&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> Stack&lt;&gt;();<span class=\"comment\">//现在都常用Deque  继承了vector的Stack效率不高</span></span><br><span class=\"line\">        TreeNode cur = root;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur!=<span class=\"keyword\">null</span> || !stack.isEmpty())&#123; <span class=\"comment\">//这里cur！=null 防止从左子树遍历到根节点后 来判断右子树是否存在，如果存在则继续遍历右子树</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span>(cur!=<span class=\"keyword\">null</span>)&#123; <span class=\"comment\">//从左子树最底层最左边的节点开始遍历</span></span><br><span class=\"line\">                stack.push(cur);</span><br><span class=\"line\">                cur = cur.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            ret.add(node.val);</span><br><span class=\"line\">            cur =node.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>官方代码</strong>：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\">lass Solution &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; res = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stk = <span class=\"keyword\">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span> || !stk.isEmpty()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                stk.push(root);</span><br><span class=\"line\">                root = root.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            root = stk.pop();</span><br><span class=\"line\">            res.add(root.val);</span><br><span class=\"line\">            root = root.right;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//由于Vector由于效率问题已经被弃用，因此继承Vector的Stack也存在效率问题，故不推荐使用。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//再一个原因是Deque双端队列可以实现多种数据结构，完全可以模拟成栈的结构。Deque上进上出，上进下出，甚至下进上出，非常上流，只有你想不到，没有我Deque做不到的。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ArrayDeque与LinkList区别：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//ArrayDeque：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组结构</span></span><br><span class=\"line\"><span class=\"comment\">//插入元素不能为null</span></span><br><span class=\"line\"><span class=\"comment\">//无法确定数据量时，后期扩容会影响效率</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//LinkList：</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//链表结构</span></span><br><span class=\"line\"><span class=\"comment\">//插入元素能为null</span></span><br><span class=\"line\"><span class=\"comment\">//无法确定数据量时，有更好表现</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>复杂度分析</strong></p>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>\n<p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>\n<h4 id=\"145-二叉树的后序遍历\"><a href=\"#145-二叉树的后序遍历\" class=\"headerlink\" title=\"145. 二叉树的后序遍历\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">145. 二叉树的后序遍历</a></h4><p>难度：简单</p>\n<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: [1,null,2,3]  </span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     2</span><br><span class=\"line\">    /</span><br><span class=\"line\">   3 </span><br><span class=\"line\"></span><br><span class=\"line\">输出: [3,2,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> List&lt;Integer&gt; <span class=\"title\">postorderTraversal</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; ret = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        Deque&lt;TreeNode&gt; stack = <span class=\"keyword\">new</span> LinkedList&lt;&gt;();</span><br><span class=\"line\">        stack.push(root);</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!stack.isEmpty())&#123;</span><br><span class=\"line\">            TreeNode node = stack.pop();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            ret.add(node.val);</span><br><span class=\"line\">            stack.push(node.left);</span><br><span class=\"line\">            stack.push(node.right);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        Collections.reverse(ret);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"BST\"><a href=\"#BST\" class=\"headerlink\" title=\"BST\"></a>BST</h2><p>二叉查找树（BST）：根节点大于等于左子树所有节点，小于等于右子树所有节点。</p>\n<p>二叉查找树中序遍历有序。</p>\n<h4 id=\"669-修剪二叉搜索树\"><a href=\"#669-修剪二叉搜索树\" class=\"headerlink\" title=\"669. 修剪二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/trim-a-binary-search-tree/\">669. 修剪二叉搜索树</a></h4><p>难度：中等</p>\n<p>给你二叉搜索树的根节点 <code>root</code> ，同时给定最小边界<code>low</code> 和最大边界 <code>high</code>。通过修剪二叉搜索树，使得所有节点的值在<code>[low, high]</code>中。修剪树不应该改变保留在树中的元素的相对结构（即，如果没有被移除，原有的父代子代关系都应当保留）。 可以证明，存在唯一的答案。</p>\n<p>所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,0,2], low = 1, high = 2</span><br><span class=\"line\">输出：[1,null,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/09/trim2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3</span><br><span class=\"line\">输出：[3,2,null,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1], low = 1, high = 2</span><br><span class=\"line\">输出：[1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2], low = 1, high = 3输出：[1,null,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,null,2], low = 2, high = 4输出：[2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数在范围 <code>[1, 104]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n<li>树中每个节点的值都是唯一的</li>\n<li>题目数据保证输入是一棵有效的二叉搜索树</li>\n<li><code>0 &lt;= low &lt;= high &lt;= 104</code></li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         this.val = val; *         this.left = left; *         this.right = right; *     &#125; * &#125; */</span><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;        <span class=\"keyword\">if</span>(root == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;        <span class=\"keyword\">if</span>(root.val &gt; high) <span class=\"keyword\">return</span> trimBST(root.left,low,high);        <span class=\"keyword\">if</span>(root.val &lt; low) <span class=\"keyword\">return</span> trimBST(root.right,low,high);        root.left = trimBST(root.left,low,high);        root.right = trimBST(root.right,low,high);        <span class=\"keyword\">return</span> root;    &#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析**</p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>N</em>)，其中 <em>N</em> 是给定的树的全部节点。我们最多访问每个节点一次。</li>\n<li>空间复杂度：<em>O</em>(<em>N</em>)，即使我们没有明确使用任何额外的内存，在最糟糕的情况下，我们递归调用的栈可能与节点数一样大。</li>\n</ul>\n<p><strong>Java具体代码解释：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">trimBST</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> low, <span class=\"keyword\">int</span> high)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (root.val &lt; low) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//因为是二叉搜索树,节点.left &lt; 节点 &lt; 节点.right</span></span><br><span class=\"line\">           <span class=\"comment\">//节点数字比low小,就把左节点全部裁掉.</span></span><br><span class=\"line\">           root = root.right;</span><br><span class=\"line\">           <span class=\"comment\">//裁掉之后,继续看右节点的剪裁情况.剪裁后重新赋值给root.</span></span><br><span class=\"line\">           root = trimBST(root, low, high);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root.val &gt; high) &#123;</span><br><span class=\"line\">           <span class=\"comment\">//如果数字比high大,就把右节点全部裁掉.</span></span><br><span class=\"line\">           root = root.left;</span><br><span class=\"line\">           <span class=\"comment\">//裁掉之后,继续看左节点的剪裁情况</span></span><br><span class=\"line\">           root = trimBST(root, low, high);</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">           <span class=\"comment\">//如果数字在区间内,就去裁剪左右子节点.</span></span><br><span class=\"line\">           root.left = trimBST(root.left, low, high);</span><br><span class=\"line\">           root.right = trimBST(root.right, low, high);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"230-二叉搜索树中第K小的元素\"><a href=\"#230-二叉搜索树中第K小的元素\" class=\"headerlink\" title=\"230. 二叉搜索树中第K小的元素\"></a><a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">230. 二叉搜索树中第K小的元素</a></h4><p>难度：中等</p>\n<p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,1,4,null,2], k = 1</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class=\"line\">输出：3</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数为 <code>n</code> 。</li>\n<li><code>1 &lt;= k &lt;= n &lt;= 104</code></li>\n<li><code>0 &lt;= Node.val &lt;= 104</code></li>\n</ul>\n<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>\n<p><strong>解析：</strong></p>\n<p>中序遍历解法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cnt =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        cnt = k;</span><br><span class=\"line\">        inOrder(root,k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode node ,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inOrder(node.left,k);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(--cnt == <span class=\"number\">0</span>) val = node.val;</span><br><span class=\"line\">        inOrder(node.right,k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种方法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> cnt =<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">kthSmallest</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        inOrder(root,k);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inOrder</span><span class=\"params\">(TreeNode node ,<span class=\"keyword\">int</span> k)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inOrder(node.left,k);</span><br><span class=\"line\">        cnt++；</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(cnt == k)&#123;</span><br><span class=\"line\">             val = node.val;</span><br><span class=\"line\">             <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125; </span><br><span class=\"line\">        inOrder(node.right,k);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"538-把二叉搜索树转换为累加树\"><a href=\"#538-把二叉搜索树转换为累加树\" class=\"headerlink\" title=\"538. 把二叉搜索树转换为累加树\"></a><a href=\"https://leetcode-cn.com/problems/convert-bst-to-greater-tree/\">538. 把二叉搜索树转换为累加树</a></h4><p>难度：中等</p>\n<p>给出二叉 <strong>搜索</strong> 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 <code>node</code> 的新值等于原树中大于或等于 <code>node.val</code> 的值之和。</p>\n<p>提醒一下，二叉搜索树满足下列约束条件：</p>\n<ul>\n<li>节点的左子树仅包含键 <strong>小于</strong> 节点键的节点。</li>\n<li>节点的右子树仅包含键 <strong>大于</strong> 节点键的节点。</li>\n<li>左右子树也必须是二叉搜索树。</li>\n</ul>\n<p><strong>注意：</strong>本题和 1038: <a href=\"https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/\">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> 相同</p>\n<p><strong>示例 1：</strong></p>\n<p><strong><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png\" alt=\"img\"></strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]</span><br><span class=\"line\">输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [0,null,1]</span><br><span class=\"line\">输出：[1,null,1]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,0,2]</span><br><span class=\"line\">输出：[3,3,2]</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,2,4,1]</span><br><span class=\"line\">输出：[7,9,4,10]</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中的节点数介于 <code>0</code> 和 <code>104</code> 之间。</li>\n<li>每个节点的值介于 <code>-104</code> 和 <code>104</code> 之间。</li>\n<li>树中的所有值 <strong>互不相同</strong> 。</li>\n<li>给定的树为二叉搜索树。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>前言</strong></p>\n<p>二叉搜索树是一棵空树，或者是具有下列性质的二叉树：</p>\n<ol>\n<li>若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li>\n<li>若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li>\n<li>它的左、右子树也分别为二叉搜索树。</li>\n</ol>\n<p>由这样的性质我们可以发现，二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。</p>\n<p><strong>方法一：反序中序遍历</strong></p>\n<p><strong>思路及算法</strong></p>\n<p>本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。</p>\n<p><strong>代码</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">convertBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            convertBST(root.right);</span><br><span class=\"line\">            sum += root.val;</span><br><span class=\"line\">            root.val = sum;</span><br><span class=\"line\">            convertBST(root.left);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二种写法</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">convertBST</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        traver(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">traver</span><span class=\"params\">(TreeNode node)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">       \ttraver(node.right);</span><br><span class=\"line\">        sum += node.val;</span><br><span class=\"line\">        node.val = sum;</span><br><span class=\"line\">        traver(node.left);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是二叉搜索树的节点数。每一个节点恰好被遍历一次。</li>\n<li>空间复杂度：<em>O</em>(<em>n</em>)，为递归过程中栈的开销，平均情况下为 O*(log<em>n</em>)，最坏情况下树呈现链状，为 O(n)*。</li>\n</ul>\n<h4 id=\"235-二叉搜索树的最近公共祖先\"><a href=\"#235-二叉搜索树的最近公共祖先\" class=\"headerlink\" title=\"235. 二叉搜索树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\">235. 二叉搜索树的最近公共祖先</a></h4><p>难度：简单</p>\n<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" alt=\"img\"></p>\n<p><strong>示例 1:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class=\"line\">输出: 6 </span><br><span class=\"line\">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class=\"line\">输出: 2</span><br><span class=\"line\">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n<p><strong>说明:</strong></p>\n<ul>\n<li>所有节点的值都是唯一的。</li>\n<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>\n</ul>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val &gt; p.val &amp;&amp; root.val&gt;q.val) <span class=\"keyword\">return</span> lowestCommonAncestor(root.left,p,q);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val  &lt; p.val &amp;&amp; root.val &lt; q.val) <span class=\"keyword\">return</span> lowestCommonAncestor(root.right,p,q);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//解释</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">lowestCommonAncestor</span><span class=\"params\">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@Author</span> biggerman</span></span><br><span class=\"line\"><span class=\"comment\">         *      二叉搜索树特性：左子树比根节点小，右子树比根节点大</span></span><br><span class=\"line\"><span class=\"comment\">         *      三种情况</span></span><br><span class=\"line\"><span class=\"comment\">         *          第一种：p，q均在root的右子树</span></span><br><span class=\"line\"><span class=\"comment\">         *          第二种：p，q均在root的左子树</span></span><br><span class=\"line\"><span class=\"comment\">         *          第三种：，最近祖先只能是root</span></span><br><span class=\"line\"><span class=\"comment\">         **/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        第一种情况，p和q都在右子树，应该把视角放在右边，去右子树找第三种情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        第二种情况，p和q都在左子树，应该把视角放在左边，去左子树找第三种情况</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"><span class=\"comment\">//        第三种情况，p,q不在同一子树，只能是p，q分别在一左一右，或者，p，q其中一个是根节点，都返回root</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"236-二叉树的最近公共祖先\"><a href=\"#236-二叉树的最近公共祖先\" class=\"headerlink\" title=\"236. 二叉树的最近公共祖先\"></a><a href=\"https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/\">236. 二叉树的最近公共祖先</a></h4><p>难度：中等</p>\n<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>\n<p><a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class=\"line\">输出：3</span><br><span class=\"line\">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2018/12/14/binarytree.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class=\"line\">输出：5</span><br><span class=\"line\">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：root = [1,2], p = 1, q = 2</span><br><span class=\"line\">输出：1</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点数目在范围 <code>[2, 105]</code> 内。</li>\n<li><code>-109 &lt;= Node.val &lt;= 109</code></li>\n<li>所有 <code>Node.val</code> <code>互不相同</code> 。</li>\n<li><code>p != q</code></li>\n<li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li>\n</ul>\n<p><strong>解析</strong>：</p>\n<p><strong>祖先的定义：</strong> 若节点 <em>p</em> 在节点 root的左（右）子树中，或 p = root，则称 root是 p 的祖先。</p>\n<p><strong>最近公共祖先的定义：</strong> 设节点 root为节点 p*,<em>q 的某公共祖先，若其左子节点 root.left和右子节点 root.right 都不是 p</em>,*q 的公共祖先，则称 root是 “最近的公共祖先” 。</p>\n<p><img src=\"https://pic.leetcode-cn.com/1599885247-rxcHcZ-Picture1.png\" alt=\"Picture1.png\"></p>\n<p><img src=\"C:\\Users\\Wanan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210717103919744.png\" alt=\"image-20210717103919744\"></p>\n<p><img src=\"https://pic.leetcode-cn.com/1599885247-mgYjRv-Picture2.png\" alt=\"Picture2.png\"></p>\n<p>考虑通过递归对二叉树进行先序遍历，当遇到节点 <em>p</em> 或 <em>q</em> 时返回。从底至顶回溯，当节点 p*,*q在节点 root的异侧时，节点 root即为最近公共祖先，则向上返回 root。</p>\n<p><img src=\"C:\\Users\\Wanan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210717103714732.png\" alt=\"image-20210717103714732\"></p>\n<blockquote>\n<p>观察发现， 情况 <code>1.</code> 可合并至 <code>3.</code> 和 <code>4.</code> 内，详见文章末尾代码。</p>\n</blockquote>\n<p><img src=\"https://pic.leetcode-cn.com/1599885247-KpxUys-Picture3.png\" alt=\"img\"></p>\n<p>1 / 18</p>\n<p><strong>复杂度分析：</strong></p>\n<ul>\n<li><strong>时间复杂度 O(N) ：</strong> 其中 <em>N</em> 为二叉树节点数；最差情况下，需要递归遍历树的所有节点。</li>\n<li><strong>空间复杂度 O(N) ：</strong> 最差情况下，递归深度达到 <em>N</em> ，系统使用 <em>O</em>(<em>N</em>) 大小的额外空间。</li>\n</ul>\n<p><strong>代码：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class=\"line\">        if(root == null || root == p || root == q) return root;</span><br><span class=\"line\">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">        if(left == null) return right;</span><br><span class=\"line\">        if(right == null) return left;</span><br><span class=\"line\">        return root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>情况 <code>1.</code> , <code>2.</code> , <code>3.</code> , <code>4.</code> 的展开写法如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class=\"line\">        if(root == null || root == p || root == q) return root;</span><br><span class=\"line\">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class=\"line\">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class=\"line\">             //这样理解可能更加清楚一点： lowestCommonAncestor这个函数不要理解为找公共祖先，而就理解为帮两个节点找祖先 传入的值是     root, p, q，帮p和q找到一个祖先就行，找到两个就更好了，如果找不到就返回NULL 在root.left里面找一次，root.right里面再找一次，如果某一边返回值是NULL， 那么说明两个值都在另一边 由于找的时候，一定是找的最近的祖先返回，所以这里直接返回前面的返回值就行了，可以保证是最近的公共祖先 如果左右的返回值都不是NULL，那说明p和q分别在两边，则当前节点就是最近公共祖先 左右都找不到就直接返回NULL</span><br><span class=\"line\"></span><br><span class=\"line\">        //这里主要是 递归 “自底而上” 的思想</span><br><span class=\"line\">        if(left == null &amp;&amp; right == null) return null; // 1.</span><br><span class=\"line\">        if(left == null) return right; // 3.</span><br><span class=\"line\">        if(right == null) return left; // 4.</span><br><span class=\"line\">        return root; // 2. if(left != null and right != null)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"108-将有序数组转换为二叉搜索树\"><a href=\"#108-将有序数组转换为二叉搜索树\" class=\"headerlink\" title=\"108. 将有序数组转换为二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\">108. 将有序数组转换为二叉搜索树</a></h4><p>难度：简单</p>\n<p>给你一个整数数组 <code>nums</code> ，其中元素已经按 <strong>升序</strong> 排列，请你将其转换为一棵 <strong>高度平衡</strong> 二叉搜索树。</p>\n<p><strong>高度平衡</strong> 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [-10,-3,0,5,9]</span><br><span class=\"line\">输出：[0,-3,9,-10,null,5]</span><br><span class=\"line\">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/02/18/btree.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：nums = [1,3]</span><br><span class=\"line\">输出：[3,1]</span><br><span class=\"line\">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= nums.length &lt;= 104</code></li>\n<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>\n<li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方法一：中序遍历，总是选择中间位置左边的数字作为根节点</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> toBST(nums,<span class=\"number\">0</span>,nums.length-<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> TreeNode <span class=\"title\">toBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums,<span class=\"keyword\">int</span> start,<span class=\"keyword\">int</span> end)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(start &gt; end) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (start + end) /<span class=\"number\">2</span>;</span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        root.left = toBST(nums,start,mid-<span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = toBST(nums,mid+<span class=\"number\">1</span>,end);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方法二：中序遍历，总是选择中间位置右边的数字作为根节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 总是选择中间位置右边的数字作为根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (left + right + <span class=\"number\">1</span>) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        root.left = helper(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = helper(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//方法三：中序遍历，选择任意一个中间位置数字作为根节点</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    Random rand = <span class=\"keyword\">new</span> Random();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> helper(nums, <span class=\"number\">0</span>, nums.length - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">helper</span><span class=\"params\">(<span class=\"keyword\">int</span>[] nums, <span class=\"keyword\">int</span> left, <span class=\"keyword\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 选择任意一个中间位置数字作为根节点</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = (left + right + rand.nextInt(<span class=\"number\">2</span>)) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(nums[mid]);</span><br><span class=\"line\">        root.left = helper(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root.right = helper(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。</p>\n<p>空间复杂度：O(logn)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(logn)。</p>\n<h4 id=\"109-有序链表转换二叉搜索树\"><a href=\"#109-有序链表转换二叉搜索树\" class=\"headerlink\" title=\"109. 有序链表转换二叉搜索树\"></a><a href=\"https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/\">109. 有序链表转换二叉搜索树</a></h4><p>难度：中等</p>\n<p>给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。</p>\n<p>本题中，一个高度平衡二叉树是指一个二叉树<em>每个节点</em> 的左右两个子树的高度差的绝对值不超过 1。</p>\n<p><strong>示例:</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">给定的有序链表： [-10, -3, 0, 5, 9],</span><br><span class=\"line\"></span><br><span class=\"line\">一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</span><br><span class=\"line\"></span><br><span class=\"line\">      0</span><br><span class=\"line\">     / \\</span><br><span class=\"line\">   -3   9</span><br><span class=\"line\">   /   /</span><br><span class=\"line\"> -10  5</span><br></pre></td></tr></table></figure>\n\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for singly-linked list.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class ListNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode next;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedListToBST</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"keyword\">null</span> ) <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head.next == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(head.val);</span><br><span class=\"line\">        ListNode preMid = getMid(head);</span><br><span class=\"line\">        ListNode mid = preMid.next;</span><br><span class=\"line\">        preMid.next = <span class=\"keyword\">null</span>;<span class=\"comment\">//断开链表</span></span><br><span class=\"line\">        <span class=\"comment\">// 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。 </span></span><br><span class=\"line\">        TreeNode t = <span class=\"keyword\">new</span> TreeNode(mid.val);</span><br><span class=\"line\">        t.left = sortedListToBST(head);</span><br><span class=\"line\">        t.right =sortedListToBST(mid.next);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ListNode <span class=\"title\">getMid</span><span class=\"params\">(ListNode head)</span></span>&#123; <span class=\"comment\">//快慢指针获取中点</span></span><br><span class=\"line\">        ListNode fast = head,slow = head,pre=<span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fast != <span class=\"keyword\">null</span>  &amp;&amp; fast.next!= <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            pre = slow;</span><br><span class=\"line\">            slow = slow.next;</span><br><span class=\"line\">            fast = fast.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>第二种写法：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> TreeNode <span class=\"title\">sortedListToBST</span><span class=\"params\">(ListNode head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (head.next == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> TreeNode(head.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 快慢指针找中心节点</span></span><br><span class=\"line\">        ListNode p = head, q = head, pre = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (q != <span class=\"keyword\">null</span> &amp;&amp; q.next != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            pre = p;</span><br><span class=\"line\">            p = p.next;</span><br><span class=\"line\">            q = q.next.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        pre.next = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       </span><br><span class=\"line\">        <span class=\"comment\">// 以升序链表的中间元素作为根节点 root，递归的构建 root 的左子树与右子树。</span></span><br><span class=\"line\">        TreeNode root = <span class=\"keyword\">new</span> TreeNode(p.val);</span><br><span class=\"line\">        root.left = sortedListToBST(head);</span><br><span class=\"line\">        root.right = sortedListToBST(p.next);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"653-两数之和-IV-输入-BST\"><a href=\"#653-两数之和-IV-输入-BST\" class=\"headerlink\" title=\"653. 两数之和 IV - 输入 BST\"></a><a href=\"https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/\">653. 两数之和 IV - 输入 BST</a></h4><p>难度：简单</p>\n<p>给定一个二叉搜索树 <code>root</code> 和一个目标结果 <code>k</code>，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 <code>true</code>。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [5,3,6,2,4,null,7], k = 9</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [5,3,6,2,4,null,7], k = 28</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 3：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [2,1,3], k = 4</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 4：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [2,1,3], k = 1</span><br><span class=\"line\">输出: false</span><br></pre></td></tr></table></figure>\n\n<p><strong>示例 5：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入: root = [2,1,3], k = 3</span><br><span class=\"line\">输出: true</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示:</strong></p>\n<ul>\n<li>二叉树的节点个数的范围是 <code>[1, 104]</code>.</li>\n<li><code>-104 &lt;= Node.val &lt;= 104</code></li>\n<li><code>root</code> 为二叉搜索树</li>\n<li><code>-105 &lt;= k &lt;= 105</code></li>\n</ul>\n<p><strong>解析：中序遍历+双指针</strong></p>\n<p>先中序遍历，将元素存入数组，再使用两数之和II的双指针方法找两个数</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findTarget</span><span class=\"params\">(TreeNode root, <span class=\"keyword\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        List&lt;Integer&gt; nums = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        inorder(root,nums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = <span class=\"number\">0</span>,j=nums.size()-<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(i&lt;j)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> sum = nums.get(i) + nums.get(j);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sum==k) <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(sum &lt; k) i++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> j--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode node,List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inorder(node.left,nums);</span><br><span class=\"line\">        nums.add(node.val);</span><br><span class=\"line\">        inorder(node.right,nums);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"530-二叉搜索树的最小绝对差\"><a href=\"#530-二叉搜索树的最小绝对差\" class=\"headerlink\" title=\"530. 二叉搜索树的最小绝对差\"></a><a href=\"https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/\">530. 二叉搜索树的最小绝对差</a></h4><p>难度：简单</p>\n<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入：</span><br><span class=\"line\"></span><br><span class=\"line\">   1</span><br><span class=\"line\">    \\</span><br><span class=\"line\">     3</span><br><span class=\"line\">    /</span><br><span class=\"line\">   2</span><br><span class=\"line\"></span><br><span class=\"line\">输出：</span><br><span class=\"line\">1</span><br><span class=\"line\"></span><br><span class=\"line\">解释：</span><br><span class=\"line\">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中至少有 2 个节点。</li>\n<li>本题与 783 <a href=\"https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/\">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li>\n</ul>\n<p><strong>解析：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeNode preNode = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getMinimumDifference</span><span class=\"params\">(TreeNode root)</span> </span>&#123;</span><br><span class=\"line\">        inorder(root);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minDiff;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode node )</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node == <span class=\"keyword\">null</span>) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">        inorder(node.left);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preNode != <span class=\"keyword\">null</span> ) minDiff = Math.min(minDiff,node.val-preNode.val);</span><br><span class=\"line\">        preNode = node;</span><br><span class=\"line\">        inorder(node.right);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(n)，其中 n 为二叉搜索树节点的个数。每个节点在中序遍历中都会被访问一次且只会被访问一次，因此总时间复杂度为 O(n)。</p>\n<p>空间复杂度：O(n)。递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到 O(n) 级别。</p>\n<h4 id=\"501-二叉搜索树中的众数\"><a href=\"#501-二叉搜索树中的众数\" class=\"headerlink\" title=\"501. 二叉搜索树中的众数\"></a><a href=\"https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/\">501. 二叉搜索树中的众数</a></h4><p>难度：简单</p>\n<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>\n<p>假定 BST 有如下定义：</p>\n<ul>\n<li>结点左子树中所含结点的值小于等于当前结点的值</li>\n<li>结点右子树中所含结点的值大于等于当前结点的值</li>\n<li>左子树和右子树都是二叉搜索树</li>\n</ul>\n<p>例如：<br>给定 BST <code>[1,null,2,2]</code>,</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">1</span><br><span class=\"line\"> \\</span><br><span class=\"line\">  2</span><br><span class=\"line\"> /</span><br><span class=\"line\">2</span><br></pre></td></tr></table></figure>\n\n<p><code>返回[2]</code>.</p>\n<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>\n<p><strong>进阶：</strong>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>\n<p><strong>解析</strong></p>\n<p><strong>方法一：中序遍历</strong></p>\n<p><strong>思路与算法</strong></p>\n<p>首先我们一定能想到一个最朴素的做法：因为这棵树的中序遍历是一个有序的序列，所以我们可以先获得这棵树的中序遍历，然后从扫描这个中序遍历序列，然后用一个哈希表来统计每个数字出现的个数，这样就可以找到出现次数最多的数字。但是这样做的空间复杂度显然不是 <em>O</em>(1) 的，原因是哈希表和保存中序遍历序列的空间代价都是 <em>O</em>(<em>n</em>)。</p>\n<p><strong>首先，我们考虑在寻找出现次数最多的数时，不使用哈希表。</strong> 这个优化是基于二叉搜索树中序遍历的性质：一棵二叉搜索树的中序遍历序列是一个非递减的有序序列。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">      1</span><br><span class=\"line\">    /   \\</span><br><span class=\"line\">   0     2</span><br><span class=\"line\">  / \\    /</span><br><span class=\"line\">-1   0  2</span><br></pre></td></tr></table></figure>\n\n<p>这样一颗二叉搜索树的中序遍历序列是 {−1,0,0,1,2,2}。我们可以发现重复出现的数字一定是一个连续出现的，例如这里的 0 和 2，它们都重复出现了，并且所有的 0 都集中在一个连续的段内，所有的 2 也集中在一个连续的段内。我们可以顺序扫描中序遍历序列，用 base 记录当前的数字，用 <em>count</em> 记录当前数字重复的次数，用 <em>maxCount</em> 来维护已经扫描过的数当中出现最多的那个数字的出现次数，用 <em>answer</em> 数组记录出现的众数。每次扫描到一个新的元素：</p>\n<p><img src=\"C:\\Users\\Wanan\\AppData\\Roaming\\Typora\\typora-user-images\\image-20210718112957683.png\" alt=\"image-20210718112957683\"></p>\n<p>我们可以把这个过程写成一个 update 函数。这样我们在寻找出现次数最多的数字的时候就可以省去一个哈希表带来的空间消耗。</p>\n<p>然后，我们考虑不存储这个中序遍历序列。 如果我们在递归进行中序遍历的过程中，访问当了某个点的时候直接使用上面的 update 函数，就可以省去中序遍历序列的空间，代码如下。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Integer&gt; answer = <span class=\"keyword\">new</span> ArrayList&lt;Integer&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> base, count, maxCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findMode(TreeNode root) &#123;</span><br><span class=\"line\">        dfs(root);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] mode = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[answer.size()];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; answer.size(); ++i) &#123;</span><br><span class=\"line\">            mode[i] = answer.get(i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">dfs</span><span class=\"params\">(TreeNode o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (o == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        dfs(o.left);</span><br><span class=\"line\">        update(o.val);</span><br><span class=\"line\">        dfs(o.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">update</span><span class=\"params\">(<span class=\"keyword\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x == base) &#123;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            count = <span class=\"number\">1</span>;</span><br><span class=\"line\">            base = x;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count == maxCount) &#123;</span><br><span class=\"line\">            answer.add(base);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &gt; maxCount) &#123;</span><br><span class=\"line\">            maxCount = count;</span><br><span class=\"line\">            answer.clear();</span><br><span class=\"line\">            answer.add(base);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for a binary tree node.</span></span><br><span class=\"line\"><span class=\"comment\"> * public class TreeNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int val;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode left;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.val = val;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.left = left;</span></span><br><span class=\"line\"><span class=\"comment\"> *         this.right = right;</span></span><br><span class=\"line\"><span class=\"comment\"> *     &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> curCnt =<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> maxCnt =<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TreeNode preNode =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span>[] findMode(TreeNode root) &#123;</span><br><span class=\"line\">        List&lt;Integer&gt; maxCntNums = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        inorder(root,maxCntNums);</span><br><span class=\"line\">        <span class=\"keyword\">int</span>[] res = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[maxCntNums.size()];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> num : maxCntNums)&#123;</span><br><span class=\"line\">            res[idx++] = num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">inorder</span><span class=\"params\">(TreeNode node ,List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(node ==<span class=\"keyword\">null</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        inorder(node.left,nums);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preNode != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(preNode.val == node.val) curCnt++;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> curCnt =<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(curCnt &gt; maxCnt)&#123;</span><br><span class=\"line\">            maxCnt= curCnt;</span><br><span class=\"line\">            nums.clear();</span><br><span class=\"line\">            nums.add(node.val);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(curCnt == maxCnt)&#123;</span><br><span class=\"line\">            nums.add(node.val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preNode = node;</span><br><span class=\"line\">        inorder(node.right,nums);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：<em>O</em>(<em>n</em>)。即遍历这棵树的复杂度。</li>\n<li>空间复杂度：<em>O</em>(<em>n</em>)。即递归的栈空间的空间代价。</li>\n</ul>\n<h2 id=\"Trie-腾讯面试有这个题\"><a href=\"#Trie-腾讯面试有这个题\" class=\"headerlink\" title=\"Trie(腾讯面试有这个题)\"></a>Trie(腾讯面试有这个题)</h2><p><a href=\"https://camo.githubusercontent.com/3ec9c694c17accef4fac75d04366dc0aac133fd904e451578417b3eb57b61944/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35633633386435392d643461652d346261342d616434342d3830626463333066333864642e6a7067\"><img src=\"https://camo.githubusercontent.com/3ec9c694c17accef4fac75d04366dc0aac133fd904e451578417b3eb57b61944/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35633633386435392d643461652d346261342d616434342d3830626463333066333864642e6a7067\" alt=\"img\"></a></p>\n<p>Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种字符串前缀。</p>\n<h4 id=\"208-实现-Trie-前缀树\"><a href=\"#208-实现-Trie-前缀树\" class=\"headerlink\" title=\"208. 实现 Trie (前缀树)\"></a><a href=\"https://leetcode-cn.com/problems/implement-trie-prefix-tree/\">208. 实现 Trie (前缀树)</a></h4><p>难度：中等</p>\n<p>**<a href=\"https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin\">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>\n<p>请你实现 Trie 类：</p>\n<ul>\n<li><code>Trie()</code> 初始化前缀树对象。</li>\n<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>\n<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>\n<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>\n</ul>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">输入</span><br><span class=\"line\">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class=\"line\">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class=\"line\">输出</span><br><span class=\"line\">[null, null, true, false, true, null, true]</span><br><span class=\"line\"></span><br><span class=\"line\">解释</span><br><span class=\"line\">Trie trie = new Trie();</span><br><span class=\"line\">trie.insert(&quot;apple&quot;);</span><br><span class=\"line\">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class=\"line\">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class=\"line\">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class=\"line\">trie.insert(&quot;app&quot;);</span><br><span class=\"line\">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>\n<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>\n<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>\n</ul>\n<p><strong>解析：</strong></p>\n<p><strong>方法一：字典树</strong></p>\n<p>Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p>\n<ul>\n<li>指向子节点的指针数组 children。对于本题而言，数组长度为 26，即小写英文字母的数量。此时 <em>children</em>[0] 对应小写字母 <em>a</em>，<em>children</em>[1] 对应小写字母 <em>b</em>，…，children*[25] 对应小写字母 <em>z</em>。</li>\n<li>布尔字段 <em>isEnd</em>，表示该节点是否为字符串的结尾。</li>\n</ul>\n<p><strong>插入字符串</strong></p>\n<p>我们从字典树的根开始，插入字符串。对于当前字符对应的子节点，有两种情况：</p>\n<ul>\n<li>子节点存在。沿着指针移动到子节点，继续处理下一个字符。</li>\n<li>子节点不存在。创建一个新的子节点，记录在 <em>children</em> 数组的对应位置上，然后沿着指针移动到子节点，继续搜索下一个字符。</li>\n</ul>\n<p>重复以上步骤，直到处理字符串的最后一个字符，然后将当前节点标记为字符串的结尾。</p>\n<p><strong>查找前缀</strong></p>\n<p>我们从字典树的根开始，查找前缀。对于当前字符对应的子节点，有两种情况：</p>\n<ul>\n<li>子节点存在。沿着指针移动到子节点，继续搜索下一个字符。</li>\n<li>子节点不存在。说明字典树中不包含该前缀，返回空指针。</li>\n</ul>\n<p>重复以上步骤，直到返回空指针或搜索完前缀的最后一个字符。</p>\n<p>若搜索到了前缀的末尾，就说明字典树中存在该前缀。此外，若前缀末尾对应节点的 <em>isEnd</em> 为真，则说明字典树中存在该字符串。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//初始化26个格子，装26个字母，索引是0-25</span></span><br><span class=\"line\">    children = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">    isEnd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//获取前缀树</span></span><br><span class=\"line\">    Trie node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch = word.charAt(i);</span><br><span class=\"line\">        <span class=\"comment\">//计算当前字符在前缀树中的索引，如果这个位置有Trie，说明当前的字符已经插过了</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = ch - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.children[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//当前的位置没有Trie，说明没插过，就插入一个Trie表示当前位置有这个字符插入了</span></span><br><span class=\"line\">            node.children[index] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//这个把当前字符的前缀树作为下个搜索的结点，Trie中的chidrean数组其实就是插入单词的             //当前的字符的后面的字符</span></span><br><span class=\"line\">        node = node.children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//表示当前的字符是某个字符串的结尾</span></span><br><span class=\"line\">    node.isEnd = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//主要看当前的字符是不是结尾字符，还是说只是当前单词的一个前缀而已</span></span><br><span class=\"line\">    Trie node = searchPrefix(word);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node != <span class=\"keyword\">null</span> &amp;&amp; node.isEnd;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> searchPrefix(prefix) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Trie <span class=\"title\">searchPrefix</span><span class=\"params\">(String prefix)</span> </span>&#123;</span><br><span class=\"line\">    Trie node = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; prefix.length(); i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> ch = prefix.charAt(i);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> index = ch - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">        <span class=\"comment\">//这里没搜到，说明当前字符后面没有字符了，没有完全匹配prefix，直接返回false表示</span></span><br><span class=\"line\">        <span class=\"comment\">//不匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (node.children[index] == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node = node.children[index];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//这里是返回最后的字符的前缀树</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><strong>自己写的代码：</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Trie</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Trie[] children;<span class=\"comment\">//指向子节点的指针数组</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> isEnd;<span class=\"comment\">//表示该节点是否为字符串的结尾</span></span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Trie</span><span class=\"params\">()</span> </span>&#123;  <span class=\"comment\">//创建对象，初始化对象的信息</span></span><br><span class=\"line\">        children = <span class=\"keyword\">new</span> Trie[<span class=\"number\">26</span>];</span><br><span class=\"line\">        isEnd = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Inserts a word into the trie. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie node = <span class=\"keyword\">this</span>; <span class=\"comment\">//本题中调用函数使用的对象均是根节点，而this指针指向对象本身（即指向根节点自己）</span></span><br><span class=\"line\">        <span class=\"comment\">// Trie node = new Trie();//不可以这样写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;word.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = word.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = ch - <span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children[index] == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">// 如果当前节点的下一个字符处还没有开辟，那就新创建一个</span></span><br><span class=\"line\">                node.children[index] = <span class=\"keyword\">new</span> Trie();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node.children[index]; <span class=\"comment\">// 节点指针后移</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node.isEnd =<span class=\"keyword\">true</span>; <span class=\"comment\">// 循环结束，当前节点指向的字符为结束字符</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns if the word is in the trie. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">search</span><span class=\"params\">(String word)</span> </span>&#123;</span><br><span class=\"line\">        Trie node = searchPrefix(word);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node != <span class=\"keyword\">null</span> &amp;&amp; node.isEnd;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">startsWith</span><span class=\"params\">(String prefix)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> searchPrefix(prefix) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Trie <span class=\"title\">searchPrefix</span><span class=\"params\">(String prefix)</span></span>&#123;</span><br><span class=\"line\">        Trie node = <span class=\"keyword\">this</span>;<span class=\"comment\">//// 从根节点开始，可以想象成一个空节点</span></span><br><span class=\"line\">        <span class=\"comment\">// Trie node = new Trie();//不可以这样写</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i= <span class=\"number\">0</span>;i&lt;prefix.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> ch = prefix.charAt(i);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> index = ch -<span class=\"string\">&#x27;a&#x27;</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(node.children[index] == <span class=\"keyword\">null</span>)&#123;<span class=\"comment\">// 如果当前节点的对应字符处尚未开辟，说明没有对应的word插入</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node = node.children[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Your Trie object will be instantiated and called as such:</span></span><br><span class=\"line\"><span class=\"comment\"> * Trie obj = new Trie();</span></span><br><span class=\"line\"><span class=\"comment\"> * obj.insert(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_2 = obj.search(word);</span></span><br><span class=\"line\"><span class=\"comment\"> * boolean param_3 = obj.startsWith(prefix);</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n","categories":["leetcode","数据结构"],"tags":["数据结构"]}]