<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-atom.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>

  <meta name="description" content="160. 相交链表难度：简单 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交：  题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1：  12345输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,">
<meta property="og:type" content="article">
<meta property="og:title" content="1.链表">
<meta property="og:url" content="http://example.com/post/3138.html">
<meta property="og:site_name" content="新的一天，每时每分每秒都应该学习">
<meta property="og:description" content="160. 相交链表难度：简单 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。 图示两个链表在节点 c1 开始相交：  题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 示例 1：  12345输入：intersectVal &#x3D; 8, listA &#x3D; [4,1,8,4,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/8f03740e93c8a0ecff54a57a25a710ab82574faf99b3efb8ddd2b6eea1d78d49-1.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/aebc5e3ef0a6b942473a7c61f4de22e268cbfbe549ff1a6ad5d3eef7c667f875-2.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/4c160db670c00f7467c1dae3b22ac117b84c0ba00690ca30708fabcdd5ff35b1-3.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/95da97748c8a006b5b827d13154bd2202bed5c2b9d779bea6467473d16fd7d66-4.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/bbc75893b050a8c482178029bd239bd75c75e6a58a4a16fb9270b13044e4ddf3-5.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/9eda023eab4ecc76af90211626f77b695a4874b451084f8e2545717347815006-6.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/1829f246e991d3e27aa3dce9b18ab88282a1bd34a5363969eb5730fe74cf8fbf-7.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/3380338ba4b563c37199b07058d35fde9f9600d3112ef0b074e5986c2f4510e1-8.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/db831df3a7db0fc405a4dc8293bfc92ba6bba6cb1719613a4e8ab7afdf2a53dd-9.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/db7d85400d03237909fc904d52b71cf721dee82af47686756400fdf4d1f07493-10.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/549d1ed958285f378aea9a0db3a603253c83aff5439a76c0b8c35f2e237b9f4b-12.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/9683a6f2e465086ca1a9bcdb6b4cce9cdcc86da3269e1009867368923c76363d-13.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/9ef5549e7ff4b4748e0ff295ee37d3e172e7b910b397aa8718110b4779a9f689-14.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/074dcf7c17ba256aedbf4ba10d101ce93ed5425a6a1aa6d296a79be7bd65fc30-15.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/f6d200f6b154e8b4e9cf86c26e90c0e71af048fd4dac2f9a35eb8c9dc93bfa15-16.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/3b5504463012d23800d78e50948d1623cf405e32072cd1c630c71636a318d002-17.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/8c474aaee63b49b4cf981637039f65a41d70979a79fec22257576cfbcfb8c4c6-18.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/5eaed6c73d6dec3c3dc7728fda178711ff1a6a558ddf8f2a1946adf22525a44c-19.JPG">
<meta property="og:image" content="https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif">
<meta property="og:image" content="https://pic.leetcode-cn.com/f89c9e095d414b8366dd7d490508ba9c99d6c93953b4429168af262169f18e83-%E5%B9%BB%E7%81%AF%E7%89%876.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/485dbe9ad44ab7b05e01c46a1bc1718187a01f8a9fe8331f497e7011f9508b57-%E5%B9%BB%E7%81%AF%E7%89%877.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/04550182527e6570d9d04f2eeae330848b83d3ff13b23ea4153410210586dc85-%E5%B9%BB%E7%81%AF%E7%89%878.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/950f6edfb553cbeec65ce3c9679dd8d3401fd1837ad9eb16989217bf83f30e58-%E5%B9%BB%E7%81%AF%E7%89%8710.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/dcd5bef9b8ff3de98e9533da7da3a8411643bbef9bc5e1a576085b4403197649-%E5%B9%BB%E7%81%AF%E7%89%8711.jpg">
<meta property="og:image" content="https://pic.leetcode-cn.com/1d6aaab3d9a42c20420fb6087e520ea05bd6d0789213f228481e55891b847b1e-%E5%B9%BB%E7%81%AF%E7%89%8712.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.sinaimg.cn%2Fmw690%2F006Tiah4zy7dwacE4z751%26690&refer=http%3A%2F%2Fs2.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629272494&t=3887a34bb0f2562d0a5ed0bc53bdab64">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/users/guanpengchn/avatar_1580451118.png?x-oss-process=image/resize,h_38,w_38/format,webp">
<meta property="og:image" content="https://pic.leetcode-cn.com/c61a88b9fe012a9b85b842f4a12a5310c96b462ea4801e6227fc6a04aa140351-frame_00001.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/87a5f06f4a257e5970af228ea0c37b1b1513d5b53770da8d409616a5fd9afaa5-frame_00002.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/b8f2dae3ca21a552bff2e2486f2f838f78aaa505066113c4453900ae182edbd3-frame_00003.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg">
<meta property="og:image" content="http://example.com/post/3138/Users/Wanan/AppData/Roaming/Typora/typora-user-images/image-20210719165432927.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/19/p3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/24/6.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612843418-hDCiPe-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612843430-WwISBz-image.png">
<meta property="og:image" content="https://pic.leetcode-cn.com/1612843449-czpjTW-image.png">
<meta property="og:image" content="https://assets.leetcode-cn.com/solution-static/328/1.png">
<meta property="article:published_time" content="2021-08-08T05:48:16.000Z">
<meta property="article:modified_time" content="2021-08-11T07:24:21.185Z">
<meta property="article:author" content="CodeRoad">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png">

<link rel="canonical" href="http://example.com/post/3138.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>1.链表 | 新的一天，每时每分每秒都应该学习</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>


<!-- 爆炸红心效果 -->
<canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
<script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
<script type="text/javascript" src="/js/firework.js"></script>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">新的一天，每时每分每秒都应该学习</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/post/3138.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1.jpg">
      <meta itemprop="name" content="CodeRoad">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="新的一天，每时每分每秒都应该学习">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          1.链表
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-08-08 13:48:16" itemprop="dateCreated datePublished" datetime="2021-08-08T13:48:16+08:00">2021-08-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-08-11 15:24:21" itemprop="dateModified" datetime="2021-08-11T15:24:21+08:00">2021-08-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/leetcode/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          
                <span>&emsp;</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span>
                <span class="post-meta-item-text">阅读次数：</span>
                <span id="busuanzi_value_page_pv"></span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>15 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4><p>难度：简单</p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_2.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1</span><br><span class="line">输出：Intersected at &#x27;2&#x27;</span><br><span class="line">解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。</span><br><span class="line">在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<p><a target="_blank" rel="noopener" href="https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2</span><br><span class="line">输出：null</span><br><span class="line">解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。</span><br><span class="line">由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。</span><br><span class="line">这两个链表不相交，因此返回 null 。</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>listA</code> 中节点数目为 <code>m</code></li>
<li><code>listB</code> 中节点数目为 <code>n</code></li>
<li><code>0 &lt;= m, n &lt;= 3 * 104</code></li>
<li><code>1 &lt;= Node.val &lt;= 105</code></li>
<li><code>0 &lt;= skipA &lt;= m</code></li>
<li><code>0 &lt;= skipB &lt;= n</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 <code>0</code></li>
<li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA + 1] == listB[skipB + 1]</code></li>
</ul>
<p><strong>进阶：</strong>你能否设计一个时间复杂度 <code>O(n)</code> 、仅用 <code>O(1)</code> 内存的解决方案？</p>
<p><strong>解析：</strong></p>
<p>空间复杂度 <em>O</em>(1) 时间复杂度为 <em>O</em>(<em>n</em>)</p>
<p>这里使用图解的方式，解释比较巧妙的一种实现。</p>
<p>根据题目意思<br>如果两个链表相交，那么相交点之后的长度是相同的</p>
<p>我们需要做的事情是，让两个链表从同距离末尾同等距离的位置开始遍历。这个位置只能是较短链表的头结点位置。<br>为此，我们必须消除两个链表的长度差</p>
<ol>
<li>指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历</li>
<li>如果 pA 到了末尾，则 pA = headB 继续遍历</li>
<li>如果 pB 到了末尾，则 pB = headA 继续遍历</li>
<li>比较长的链表指针指向较短链表head时，长度差就消除了</li>
<li>如此，只需要将最短链表遍历两次即可找到位置</li>
</ol>
<p>听着可能有点绕，看图最直观，链表的题目最适合看图了</p>
<p><img src="https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png" alt="相交链表.png"></p>
<p>代码也很简单（此处代码是参考评论区的高手的）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//若相交，链表A： a+c, 链表B : b+c. a+c+b+c = b+c+a+c 。则会在公共处c起点相遇。若不相交，a +b = b+a 。</span></span><br><span class="line"><span class="comment">//题解：设链表A的长度为a+c，链表B的长度为b+c，a为链表A不公共部分，b为链表B不公共部分，c为链表A、B的公共部分,将两个链表连起来，A-&gt;B和B-&gt;A，长度：a+c+b+c=b+c+a+c，若链表AB相交，则a+c+b与b+c+a就会抵消，它们就会在c处相遇；若不相交，则c为nullptr，则a+b=b+a，它们各自移动到尾部循环结束，即返回nullptr</span></span><br><span class="line">    </span><br><span class="line">    ListNode pA = headA, pB = headB;</span><br><span class="line"><span class="comment">//当pA或pB为空时，它们开始指向另一链表的头部，每次判断pA或pB是否为空进行赋值的好处是当链表AB没有公共部分时pA和pB同时为空，这样避免了死循环  (也即遍历两遍)</span></span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度O(m+n)，其中 m 和 n 是分别是链表 headA 和headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。</p>
<p>空间复杂度：O(1)。</p>
<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h4><p>难度简单1845</p>
<p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 5000]</code></li>
<li><code>-5000 &lt;= Node.val &lt;= 5000</code></li>
</ul>
<p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p>
<p><strong>解析：</strong>原作者链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">动画演示+多种解法 206. 反转链表 - 反转链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><strong>利用外部空间</strong></p>
<p>这种方式很简单，先申请一个动态扩容的数组或者容器，比如 ArrayList 这样的。<br>然后不断遍历链表，将链表中的元素添加到这个容器中。<br>再利用容器自身的 API，反转整个容器，这样就达到反转的效果了。<br>最后同时遍历容器和链表，将链表中的值改为容器中的值。<br>因为此时容器的值是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 4 3 2 1</span><br></pre></td></tr></table></figure>

<p>链表按这个顺序重新被设置一边，就达到要求啦。<br>当然你可以可以再新创建 N 个节点，然后再返回，这样也可以达到目的。<br>这种方式很简单，但你在面试中这么做的话，面试官 100% 会追问是否有更优的方式，比如不用外部空间。所以我就不做代码和动画演示了，下面来看看如何用 <em>O</em>(1) 空间复杂度来实现这道题。</p>
<p><strong>双指针迭代</strong></p>
<p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。<br>第二个指针 cur 指向 head，然后不断遍历 cur。<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了。<br>动画演示如下：<br><img src="https://pic.leetcode-cn.com/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt="迭代.gif"></p>
<p>动画演示中其实省略了一个<code>tmp</code>变量，这个<code>tmp</code>变量会将<code>cur</code>的下一个节点保存起来，考虑到一张动画放太多变量会很混乱，所以我就没加了，具体详细执行过程，请点击下面的幻灯片查看。</p>
<p><img src="https://pic.leetcode-cn.com/8f03740e93c8a0ecff54a57a25a710ab82574faf99b3efb8ddd2b6eea1d78d49-1.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/aebc5e3ef0a6b942473a7c61f4de22e268cbfbe549ff1a6ad5d3eef7c667f875-2.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/4c160db670c00f7467c1dae3b22ac117b84c0ba00690ca30708fabcdd5ff35b1-3.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/95da97748c8a006b5b827d13154bd2202bed5c2b9d779bea6467473d16fd7d66-4.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/bbc75893b050a8c482178029bd239bd75c75e6a58a4a16fb9270b13044e4ddf3-5.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/9eda023eab4ecc76af90211626f77b695a4874b451084f8e2545717347815006-6.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1829f246e991d3e27aa3dce9b18ab88282a1bd34a5363969eb5730fe74cf8fbf-7.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/3380338ba4b563c37199b07058d35fde9f9600d3112ef0b074e5986c2f4510e1-8.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/db831df3a7db0fc405a4dc8293bfc92ba6bba6cb1719613a4e8ab7afdf2a53dd-9.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/db7d85400d03237909fc904d52b71cf721dee82af47686756400fdf4d1f07493-10.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/549d1ed958285f378aea9a0db3a603253c83aff5439a76c0b8c35f2e237b9f4b-12.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/9683a6f2e465086ca1a9bcdb6b4cce9cdcc86da3269e1009867368923c76363d-13.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/9ef5549e7ff4b4748e0ff295ee37d3e172e7b910b397aa8718110b4779a9f689-14.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/074dcf7c17ba256aedbf4ba10d101ce93ed5425a6a1aa6d296a79be7bd65fc30-15.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/f6d200f6b154e8b4e9cf86c26e90c0e71af048fd4dac2f9a35eb8c9dc93bfa15-16.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/3b5504463012d23800d78e50948d1623cf405e32072cd1c630c71636a318d002-17.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/8c474aaee63b49b4cf981637039f65a41d70979a79fec22257576cfbcfb8c4c6-18.JPG" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/5eaed6c73d6dec3c3dc7728fda178711ff1a6a558ddf8f2a1946adf22525a44c-19.JPG" alt="img"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;	<span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;		<span class="comment">//申请节点，pre和 cur，pre指向null		ListNode pre = null;		ListNode cur = head;		ListNode tmp = null;		while(cur!=null) &#123;			//记录当前节点的下一个节点			tmp = cur.next;			//然后将当前节点指向pre			cur.next = pre;			//pre和cur节点都前进一位			pre = cur;			cur = tmp;		&#125;		return pre;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>递归解法</strong></p>
<p>这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。<br>递归的两个条件：</p>
<ol>
<li>终止条件是当前节点或者下一个节点==null</li>
<li>在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head</span><br></pre></td></tr></table></figure>

<p>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：<br><img src="https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt="递归.gif"></p>
<p><strong>幻灯片演示</strong></p>
<p>感谢<a target="_blank" rel="noopener" href="https://leetcode-cn.com/u/zhuuuu-2/">@zhuuuu-2</a>的建议，递归的解法光看动画比较容易理解，但真到了代码层面理解起来可能会有些困难，我补充了下递归调用的详细执行过程。</p>
<p>以<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>这个链表为例，整个递归调用的执行过程，对应到代码层面(用java做示范)是怎么执行的，以及递归的调用栈都列出来了，请点击下面的幻灯片查看吧。</p>
<p><img src="https://pic.leetcode-cn.com/f89c9e095d414b8366dd7d490508ba9c99d6c93953b4429168af262169f18e83-%E5%B9%BB%E7%81%AF%E7%89%876.jpg" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/485dbe9ad44ab7b05e01c46a1bc1718187a01f8a9fe8331f497e7011f9508b57-%E5%B9%BB%E7%81%AF%E7%89%877.jpg" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/04550182527e6570d9d04f2eeae330848b83d3ff13b23ea4153410210586dc85-%E5%B9%BB%E7%81%AF%E7%89%878.jpg" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/950f6edfb553cbeec65ce3c9679dd8d3401fd1837ad9eb16989217bf83f30e58-%E5%B9%BB%E7%81%AF%E7%89%8710.jpg" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/dcd5bef9b8ff3de98e9533da7da3a8411643bbef9bc5e1a576085b4403197649-%E5%B9%BB%E7%81%AF%E7%89%8711.jpg" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/1d6aaab3d9a42c20420fb6087e520ea05bd6d0789213f228481e55891b847b1e-%E5%B9%BB%E7%81%AF%E7%89%8712.jpg" alt="img"></p>
<p>代码实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//解释reverseList: head=1    reverseList: head=2	    reverseList: head=3		    reverseList:head=4			    reverseList:head=5 					终止返回				cur = 5				4.next.next-&gt;4，即5-&gt;4			cur=5			3.next.next-&gt;3，即4-&gt;3		cur = 5		2.next.next-&gt;2，即3-&gt;2	cur = 5	1.next.next-&gt;1，即2-&gt;1		最后返回cur</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;	<span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;		<span class="comment">//递归终止条件是当前为空，或者下一个节点为空		if(head==null || head.next==null) &#123;			return head;		&#125;		//这里的cur就是最后一个节点		ListNode cur = reverseList(head.next);		//这里请配合动画演示理解		//如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5		//而head是4，head的下一个是5，下下一个是空		//所以head.next.next 就是5-&gt;4		head.next.next = head;		//防止链表循环，需要将head.next设置为空		head.next = null;		//每层递归函数都返回cur，也就是最后一个节点		return cur;	&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h4><p>难度简单</p>
<p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = []输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [], l2 = [0]输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>两个链表的节点数目范围是 <code>[0, 50]</code></li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li>
</ul>
<p><strong>解析：</strong>解题链接：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/">合并两个有序链表 - 合并两个有序链表 - 力扣（LeetCode） (leetcode-cn.com)</a></p>
<p><strong>递归：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">解释：<span class="comment">//(1,1):代表第一次进入递归函数，并且从第一个口进入，并且记录进入前链表的状态merge(1,1): 1-&gt;4-&gt;5-&gt;null, 1-&gt;2-&gt;3-&gt;6-&gt;null    merge(2,2): 4-&gt;5-&gt;null, 1-&gt;2-&gt;3-&gt;6-&gt;null    	merge(3,2): 4-&gt;5-&gt;null, 2-&gt;3-&gt;6-&gt;null    		merge(4,2): 4-&gt;5-&gt;null, 3-&gt;6-&gt;null    			merge(5,1): 4-&gt;5-&gt;null, 6-&gt;null    				merge(6,1): 5-&gt;null, 6-&gt;null    					merge(7): null, 6-&gt;null    					return l2    				l1.next --- 5-&gt;6-&gt;null, return l1    			l1.next --- 4-&gt;5-&gt;6-&gt;null, return l1    		l2.next --- 3-&gt;4-&gt;5-&gt;6-&gt;null, return l2    	l2.next --- 2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null, return l2    l2.next --- 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null, return l2l1.next --- 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null, return l1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;            <span class="keyword">return</span> l2;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;            <span class="keyword">return</span> l1;        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;            l1.next = mergeTwoLists(l1.next, l2);            <span class="keyword">return</span> l1;        &#125; <span class="keyword">else</span> &#123;            l2.next = mergeTwoLists(l1, l2.next);            <span class="keyword">return</span> l2;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次调用递归都会去掉 l1 或者 l2 的头节点（直到至少有一个链表为空），函数 mergeTwoList 至多只会递归调用每个节点一次。因此，时间复杂度取决于合并后的链表长度，即O(n+m)。</p>
</li>
<li><p>空间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。递归调用 mergeTwoLists 函数时需要消耗栈空间，栈空间的大小取决于递归调用的深度。结束递归调用时 mergeTwoLists 函数最多调用 n+m 次，因此空间复杂度为O(n+m)。</p>
</li>
</ul>
<p><strong>迭代：</strong></p>
<p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fs2.sinaimg.cn%2Fmw690%2F006Tiah4zy7dwacE4z751%26690&refer=http%3A%2F%2Fs2.sinaimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1629272494&t=3887a34bb0f2562d0a5ed0bc53bdab64" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;        ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>)<span class="comment">//新建哑节点（伪头节点），值为-1，哑节点不是头节点，是新造的一个伪头节点，但是它存储的地址和头节点一样        ListNode prev = prehead;//之所以赋值给prev  这里prev可以当作游标往后移动，否则最后返回prev就不对        while (l1 != null &amp;&amp; l2 != null) &#123;            if (l1.val &lt;= l2.val) &#123;                prev.next = l1;                l1 = l1.next;            &#125; else &#123;                prev.next = l2;                l2 = l2.next;            &#125;            prev = prev.next;        &#125;        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可        prev.next = l1 == null ? l2 : l1;        return prehead.next;//下一节点地址。相当于头节点     &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>复杂度分析</p>
<p>时间复杂度：O(n+m)，其中 n 和 m 分别为两个链表的长度。因为每次循环迭代中，l1 和 l2 只有一个元素会被放进合并链表中， 因此 while 循环的次数不会超过两个链表的长度之和。所有其他操作的时间复杂度都是常数级别的，因此总的时间复杂度为 O(n+m)。</p>
<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>
<h4 id="83-删除排序链表中的重复元素"><a href="#83-删除排序链表中的重复元素" class="headerlink" title="83. 删除排序链表中的重复元素"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4><p>难度简单608</p>
<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>
<p>返回同样按升序排列的结果链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2]输出：[1,2]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]输出：[1,2,3]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序排列</li>
</ul>
<p><strong>解析：</strong></p>
<p><strong>递归</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;        head.next = deleteDuplicates(head.next);        <span class="keyword">return</span>  head.val == head.next.val ? head.next:head;           &#125;&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/users/guanpengchn/avatar_1580451118.png?x-oss-process=image/resize,h_38,w_38/format,webp" alt="img"></p>
<p><strong>思路</strong></p>
<ul>
<li>标签：链表</li>
<li>指定 cur 指针指向头部 head</li>
<li>当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了</li>
<li>当 cur.val 和 cur.next.val 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果</li>
<li>如果不相等则 cur 移动到下一个位置继续循环</li>
<li>时间复杂度：<em>O</em>(<em>n</em>)</li>
</ul>
<p><strong>代码</strong></p>
<ul>
<li><strong>迭代</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123;    public ListNode deleteDuplicates(ListNode head) &#123;                ListNode cur = head;        while(cur != null &amp;&amp; cur.next != null) &#123;//因为测试的时候的链表可能给的[] 所以cur!=null的判定也要给上~            if(cur.val == cur.next.val) &#123;                //因为是升序排列 所以也只可能是挨着的二位相同辽~                cur.next = cur.next.next;//删除重复的辣个cur.next            &#125;            else &#123;                cur = cur.next;//cur继续前移            &#125;        &#125;        return head;//返回结果链表    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>画解</strong></p>
<p><img src="https://pic.leetcode-cn.com/c61a88b9fe012a9b85b842f4a12a5310c96b462ea4801e6227fc6a04aa140351-frame_00001.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/87a5f06f4a257e5970af228ea0c37b1b1513d5b53770da8d409616a5fd9afaa5-frame_00002.png" alt="img"></p>
<p><img src="https://pic.leetcode-cn.com/b8f2dae3ca21a552bff2e2486f2f838f78aaa505066113c4453900ae182edbd3-frame_00003.png" alt="img"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的长度。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h4 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h4><p>难度中等1457</p>
<p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><strong>进阶：</strong>你能尝试使用一趟扫描实现吗？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], n = 1输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], n = 1输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中结点的数目为 <code>sz</code></li>
<li><code>1 &lt;= sz &lt;= 30</code></li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
<li><code>1 &lt;= n &lt;= sz</code></li>
</ul>
<p><strong>解析：</strong></p>
<p><img src="/post/3138/Users/Wanan\AppData\Roaming\Typora\typora-user-images\image-20210719165432927.png" alt="image-20210719165432927"></p>
<p><img src="https://assets.leetcode-cn.com/solution-static/19/p3.png" alt="p3"></p>
<p><strong>官方代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);        ListNode first = head;        ListNode second = dummy;        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;            first = first.next;        &#125;        <span class="keyword">while</span> (first != <span class="keyword">null</span>) &#123;            first = first.next;            second = second.next;        &#125;        second.next = second.next.next;        ListNode ans = dummy.next;        <span class="keyword">return</span> ans;    &#125;&#125;因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 start.next != <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p><strong>自己代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;        ListNode fast = head;        <span class="keyword">while</span>(n-- &gt;<span class="number">0</span>)&#123;            fast = fast.next;        &#125;        <span class="keyword">if</span>(fast == <span class="keyword">null</span>)  <span class="keyword">return</span> head.next;<span class="comment">//如果fast == null  说明fast经过以为遍历到了最后一个节点的后一位，此时n = 链表长度，说明要删除的是第一个节点。        ListNode slow = head;        while(fast.next != null)&#123;//因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 fast.next != null            fast = fast.next;            slow = slow.next;        &#125;        slow.next = slow.next.next;        return head;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>L</em>)，其中 <em>L</em> 是链表的长度。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4><p>难度中等973</p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]输出：[2,1,4,3]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []输出：[]</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]输出：[1]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 100</code></li>
</ul>
<p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p>
<p><strong>解析：</strong></p>
<p><strong>方法二：迭代</strong></p>
<p><strong>思路与算法</strong></p>
<p>也可以通过迭代的方式实现两两交换链表中的节点。</p>
<p>创建哑结点 <code>dummyHead</code>，令 <code>dummyHead.next = head</code>。令 <code>temp</code> 表示当前到达的节点，初始时 <code>temp = dummyHead</code>。每次需要交换 <code>temp</code> 后面的两个节点。</p>
<p>如果 <code>temp</code> 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 <code>temp</code> 后面的两个节点 <code>node1</code> 和 <code>node2</code>，通过更新节点的指针关系实现两两交换节点。</p>
<p>具体而言，交换之前的节点关系是 <code>temp -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>temp -&gt; node2 -&gt; node1</code>，因此需要进行如下操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">temp.next = node2node1.next = node2.nextnode2.next = node1</span><br></pre></td></tr></table></figure>

<p>完成上述操作之后，节点关系即变成 <code>temp -&gt; node2 -&gt; node1</code>。再令 <code>temp = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>
<p>两两交换链表中的节点之后，新的链表的头节点是 <code>dummyHead.next</code>，返回新的链表的头节点即可。</p>
<p><img src="https://assets.leetcode-cn.com/solution-static/24/6.png" alt="img"></p>
<p>6 / 13</p>
<p><strong>代码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;    public ListNode swapPairs(ListNode head) &#123;        ListNode dummyHead = new ListNode(0);//创建一个头节点        dummyHead.next = head;        ListNode temp = dummyHead;        while (temp.next != null &amp;&amp; temp.next.next != null) &#123;            ListNode node1 = temp.next;            ListNode node2 = temp.next.next;            temp.next = node2;            node1.next = node2.next;            node2.next = node1;            temp = node1;        &#125;        return dummyHead.next;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<em>O</em>(<em>n</em>)，其中 <em>n</em> 是链表的节点数量。需要对每个节点进行更新指针的操作。</li>
<li>空间复杂度：<em>O</em>(1)。</li>
</ul>
<h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h4><p>难度中等</p>
<p>给你两个 <strong>非空</strong> 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
<p><strong>示例1：</strong></p>
<p><img src="https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [7,2,4,3], l2 = [5,6,4]输出：[7,8,0,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]输出：[8,0,7]</span><br></pre></td></tr></table></figure>

<p><strong>示例3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]输出：[0]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li>链表的长度范围为<code> [1, 100]</code></li>
<li><code>0 &lt;= node.val &lt;= 9</code></li>
<li>输入数据保证链表代表的数字无前导 0</li>
</ul>
<p><strong>进阶：</strong>如果输入链表不能修改该如何处理？换句话说，不能对列表中的节点进行翻转。</p>
<p><strong>解析：</strong></p>
<p>这道题可以通过使用栈来解决，我们需要构建两个栈，将两个链表中的值分别压入这两个栈中。</p>
<p><img src="https://pic.leetcode-cn.com/1612843418-hDCiPe-image.png" alt="image.png"></p>
<p>每次都从两个栈中各弹出一个元素，就是我们所需要的最末位元素，按照计算方式，相加取模求当前位的值，同时我们还需要记录当前位的进位。最后，我们使用获得的值，构建一个节点。</p>
<p><img src="https://pic.leetcode-cn.com/1612843430-WwISBz-image.png" alt="image.png"></p>
<p>我们需要使用一个指针作为头指针，指向当前节点。每次新增节点，我们只需要将新节点插入到头指针之后即可。</p>
<p><img src="https://pic.leetcode-cn.com/1612843449-czpjTW-image.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;        Deque&lt;Integer&gt; stack1  =  <span class="keyword">new</span> LinkedList&lt;&gt;();        Deque&lt;Integer&gt; stack2  =  <span class="keyword">new</span> LinkedList&lt;&gt;();        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;            stack1.push(l1.val);            l1 = l1.next;        &#125;        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;            stack2.push(l2.val);            l2 = l2.next;        &#125;        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);<span class="comment">//创建一个头节点        int carry =0;//存储进位        while(!stack1.isEmpty() || !stack2.isEmpty() || carry!=0)&#123;            int x = stack1.isEmpty() ? 0:stack1.pop();            int y = stack2.isEmpty() ? 0:stack2.pop();            int sum  = x + y + carry;            carry = sum /10;            ListNode tmp =new ListNode(sum %10);            tmp.next = head.next;//把当前节点的下一节点指向头节点的下一个节点                      head.next = tmp;//再把当前节点 变为头节点下一节点           &#125;        return head.next;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过栈的形式：实现两个链表相加    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;        //创建两个栈：存放两个链表的value        Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;();      //存放l1的value        Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();      //存放l2的value        //创建一个：指向null的结点        ListNode head = null;                   //将l1的value放入：stack1        while(l1 != null)&#123;            stack1.push(l1.val);            l1 = l1.next;        &#125;        //将l2的value放入：stack2        while(l2 != null)&#123;            stack2.push(l2.val);            l2 = l2.next;        &#125;        //自定义：循环变量        int carry = 0;               //记录：来自低位的进位        int num = 0;                 //记录两个链表相加的：value值        ListNode newNode = null;    //用于记录：新链表，创建的结点        //循环判断        while(!stack1.empty() || !stack2.empty() || carry &gt; 0)&#123;            //循环体            num = carry;           //记录来自：低位的进位， 如果没有，则为0，否则为1            num += stack1.empty() ? 0:stack1.pop();     //加上l1的栈顶value            num += stack2.empty() ? 0:stack2.pop();     //加上l2的栈顶value            //改变变量            newNode = new ListNode(num%10);            //利用头插法：插入到新链表            newNode.next = head;                        //指向第一个有效结点            head = newNode;                             //第一个有效结点：向前移动            carry = num/10;                              //记录：进位        &#125;      return head;    &#125;</span></span><br></pre></td></tr></table></figure>



<h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4><p>难度简单1049</p>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2输出: false</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1输出: true</span><br></pre></td></tr></table></figure>

<p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
<p><strong>方法三：快慢指针</strong><br><strong>思路</strong></p>
<p>避免使用 O(n) 额外空间的方法就是改变输入。</p>
<p>我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。</p>
<p>该方法虽然可以将空间复杂度降到 O(1)，但是在并发环境下，该方法也有缺点。在并发环境下，函数运行时需要锁定其他线程或进程对链表的访问，因为在函数执行过程中链表会被修改。</p>
<p><strong>算法</strong></p>
<p>整个流程可以分为以下五个步骤：</p>
<ol>
<li>找到前半部分链表的尾节点。</li>
<li>反转后半部分链表。</li>
<li>判断是否回文。</li>
<li>恢复链表。</li>
<li>返回结果。</li>
</ol>
<p>执行步骤一，我们可以计算链表节点的数量，然后遍历链表找到前半部分的尾节点。</p>
<p>我们也可以使用快慢指针在一次遍历中找到：慢指针一次走一步，快指针一次走两步，快慢指针同时出发。当快指针移动到链表的末尾时，慢指针恰好到链表的中间。通过慢指针将链表分为两部分。</p>
<p>若链表有奇数个节点，则中间的节点应该看作是前半部分。</p>
<p>步骤二可以使用「206. 反转链表」问题中的解决方法来反转链表的后半部分。</p>
<p>步骤三比较两个部分的值，当后半部分到达末尾则比较完成，可以忽略计数情况中的中间节点。</p>
<p>步骤四与步骤二使用的函数相同，再反转一次恢复链表本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;        <span class="comment">//找到前半部分链表的尾节点并反转后半部分链表        ListNode firstHalfEnd = endOfFirstHalf(head);        ListNode secondHalfStart = reverseList(firstHalfEnd.next);              //判断是否回文        ListNode p1 = head;        ListNode p2 = secondHalfStart;        boolean result = true;        while(result &amp;&amp; p2 != null)&#123; //因为链表奇数点时，奇数点属于前一链表，所以后半部分总比前半部分少, 所以判断p2是否等于null        if(p1.val != p2.val)&#123;            result =false;        &#125;        p1 = p1.next;        p2 = p2.next;        &#125;        //还原链表并返回结果        firstHalfEnd.next = reverseList(secondHalfStart);        return result;    &#125;    public ListNode endOfFirstHalf(ListNode head)&#123;        ListNode fast =head,slow = head;        while(fast.next != null &amp;&amp; fast.next.next != null)&#123;            fast = fast.next.next;            slow = slow.next;        &#125;        return slow;    &#125;    public  ListNode reverseList(ListNode head)&#123;        ListNode newHead = null;//新建的一个头节点        while(head != null)&#123;            ListNode temNode = head.next;            head.next = newHead;            newHead = head;            head = temNode;        &#125;        return newHead;    &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(n)，其中 n 指的是链表的大小。</p>
<p>空间复杂度：O(1)。我们只会修改原本链表中节点的指向，而在堆栈上的堆栈帧不超过 O(1)。</p>
<h4 id="725-分隔链表"><a href="#725-分隔链表" class="headerlink" title="725. 分隔链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h4><p>难度中等146</p>
<p>给定一个头结点为 <code>root</code> 的链表, 编写一个函数以将链表分隔为 <code>k</code> 个连续的部分。</p>
<p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p>
<p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p>
<p>返回一个符合上述规则的链表的列表。</p>
<p>举例： 1-&gt;2-&gt;3-&gt;4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1, 2, 3], k = 5输出: [[1],[2],[3],[],[]]解释:输入输出各部分都应该是链表，而不是数组。例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3输出: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]解释:输入被分成了几个连续的部分，并且每部分的长度相差不超过1.前面部分的长度大于等于后面部分的长度。</span><br></pre></td></tr></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>root</code> 的长度范围： <code>[0, 1000]</code>.</li>
<li>输入的每个节点的大小范围：<code>[0, 999]</code>.</li>
<li><code>k</code> 的取值范围： <code>[1, 50]</code>.</li>
</ul>
<p> <strong>解析：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * Definition for singly-linked list. * public class ListNode &#123; *     int val; *     ListNode next; *     ListNode() &#123;&#125; *     ListNode(int val) &#123; this.val = val; &#125; *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */</span><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode head, <span class="keyword">int</span> k) &#123;<span class="comment">//这里的head直接指向第一个有效节点的地址。与c++不一样        int N = 0;        ListNode cur = head;//避免以后找不到head        //遍历链表长度        while(cur != null)&#123;            N++;            cur = cur.next;        &#125;        int size = N/k;        int mod = N%k;        ListNode[] res = new ListNode[k];        cur = head;//重置cur 为head起点        for(int i =0;cur!=null&amp;&amp;i&lt;k;i++)&#123;//这里外循环是遍历k段链表            res[i] = cur;            int curSize = size + (mod-- &gt;0 ? 1:0);            for(int j =0;j&lt;curSize-1;j++)&#123;// 假如18个数，分为5段，那么就是4，4，4，3，3. 这里curSize = 4              //curSize-1 =3    那么从1开始遍历三次 也就是0，1，2即可。1-&gt;2-&gt;3-&gt;4有三个指针                cur = cur.next;            &#125;            //断开每部分链表            ListNode next =cur.next;            cur.next = null;            cur = next;        &#125;        return res;    &#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N+k)。N 指的是所给链表的结点数，若 k 很大，则还需要添加许多空列表。</li>
<li>空间复杂度：O(k)，存储答案时所需的额外空格。</li>
</ul>
<h4 id="328-奇偶链表"><a href="#328-奇偶链表" class="headerlink" title="328. 奇偶链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h4><p>难度中等443</p>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL 输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
<p><strong>解析：</strong></p>
<p><img src="https://assets.leetcode-cn.com/solution-static/328/1.png" alt="fig1"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度：O(n)，其中 n 是链表的节点数。需要遍历链表中的每个节点，并更新指针。</p>
</li>
<li><p>空间复杂度：O(1)。只需要维护有限的指针。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/post/33019.html" rel="prev" title="1.双指针">
      <i class="fa fa-chevron-left"></i> 1.双指针
    </a></div>
      <div class="post-nav-item">
    <a href="/post/46952.html" rel="next" title="2.树">
      2.树 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">1.</span> <span class="nav-text">160. 相交链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">206. 反转链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">21. 合并两个有序链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="nav-number">4.</span> <span class="nav-text">83. 删除排序链表中的重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">5.</span> <span class="nav-text">19. 删除链表的倒数第 N 个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">6.</span> <span class="nav-text">24. 两两交换链表中的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#445-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">7.</span> <span class="nav-text">445. 两数相加 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#234-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">8.</span> <span class="nav-text">234. 回文链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#725-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="nav-number">9.</span> <span class="nav-text">725. 分隔链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="nav-number">10.</span> <span class="nav-text">328. 奇偶链表</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="CodeRoad"
      src="/images/1.jpg">
  <p class="site-author-name" itemprop="name">CodeRoad</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/LoverDXL" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;LoverDXL" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
      

      
      <script type="text/javascript" charset="utf-8" src="/js/tagcloud.js"></script>
      <script type="text/javascript" charset="utf-8" src="/js/tagcanvas.js"></script>
      <div class="widget-wrap">
        <h3 class="widget-title">Tag Cloud</h3>
        <div id="myCanvasContainer" class="widget tagcloud">
            <canvas width="250" height="250" id="resCanvas" style="width=100%">
                <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9D%82%E8%AF%86/" rel="tag">杂识</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">2</span></li></ul>
            </canvas>
        </div>
      </div>
      
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CodeRoad</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">141k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:09</span>
</div>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("8/6/2021 12:00:00");//在此处修改你的建站时间
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = " Runing "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + "小 时 " + mnum + " 分 " + snum + " 秒"; 
    } 
setInterval("createtime()",250);
</script>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共58.3k字</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <span class="site-uv" title="总访客量">
    我的第<span id="busuanzi_value_site_uv"></span>位朋友, 
  </span>

  <span class="site-pv" title="总访问量">
    经过<span id="busuanzi_value_site_pv"></span>次回眸与你相遇
  </span>
</div>







      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  
 
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/assets/hibiki.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":true}});</script></body>
</html>
